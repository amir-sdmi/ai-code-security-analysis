// Generated by Copilot
import { Injectable, Logger } from '@nestjs/common';
import { Throttle } from '@nestjs/throttler';
import {
  ConnectedSocket,
  MessageBody,
  WebSocketGateway as NestWebSocketGateway,
  OnGatewayConnection,
  OnGatewayDisconnect,
  OnGatewayInit,
  SubscribeMessage,
  WebSocketServer,
  WsResponse,
} from '@nestjs/websockets';
import { Observable, from } from 'rxjs';
import { Server, Socket } from 'socket.io';
import { z } from 'zod';

// Type-safe subscription requests
const LeaderboardSubscriptionSchema = z.object({
  timeFrame: z.enum(['daily', 'weekly', 'monthly', 'all']).optional(),
  limit: z.number().min(1).max(100).optional(),
});

type LeaderboardSubscription = z.infer<typeof LeaderboardSubscriptionSchema>;

// Event payload interfaces for better type safety
interface LeaderboardUpdate {
  rankings: Array<{
    walletAddress: string;
    score: number;
    rank: number;
    username?: string;
    avatar?: string;
  }>;
  updatedAt: string;
  timeFrame: 'daily' | 'weekly' | 'monthly' | 'all';
}

interface WalletNotification {
  type: 'achievement' | 'reward' | 'system' | 'social';
  message: string;
  timestamp: string;
  data?: Record<string, unknown>;
}

/**
 * WebSocket gateway for real-time updates
 * Handles leaderboard updates and wallet connection events
 * Enhanced with NestJS 11 features and improved error handling
 */
@Injectable()
@NestWebSocketGateway({
  namespace: 'ws',
  cors: {
    origin: process.env.CORS_ORIGIN?.split(',') || 'http://localhost:3000',
    credentials: true,
    methods: ['GET', 'POST'],
  },
  transports: ['websocket'],
  pingInterval: 10000, // 10 seconds ping
  pingTimeout: 5000, // 5 seconds ping timeout
  connectTimeout: 10000, // 10 seconds connection timeout
})
export class WebSocketGateway
  implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer() server!: Server;
  private readonly logger = new Logger(WebSocketGateway.name);
  private activeConnections = 0;
  // Track subscriptions for cleanup and analytics
  private clientSubscriptions = new Map<string, Set<string>>();
  // Throttling for aggressive clients
  private readonly messageCounters = new Map<
    string,
    { count: number; timestamp: number }
  >();
  private readonly maxMessagesPerMinute = 300;

  /**
   * Called when the gateway is initialized
   * @param server The Socket.IO server instance
   */
  afterInit(server: Server): void {
    this.logger.log('WebSocket Gateway initialized');

    // Set up periodic cleanup of inactive clients
    setInterval(() => this.cleanupInactiveClients(), 60000); // Every minute

    // Set up error handling for the server
    server.engine.on('connection_error', (err) => {
      this.logger.error(`Connection error: ${err.message}`, err.stack);
    });
  }

  /**
   * Called when a client connects
   * @param client The connected client socket
   */
  handleConnection(client: Socket): void {
    try {
      this.activeConnections++;
      const clientId = client.id;
      const query = client.handshake.query;

      // Initialize client subscription tracking
      this.clientSubscriptions.set(clientId, new Set());

      this.logger.log(
        `Client connected: ${clientId} (${this.activeConnections} active connections)`,
      );

      // If wallet address provided in connection query, join a room for that wallet
      const walletAddress = query.walletAddress as string;
      if (walletAddress) {
        // Validate wallet address format (simple example)
        if (!/^0x[a-fA-F0-9]{40}$/.test(walletAddress)) {
          this.logger.warn(`Invalid wallet address format: ${walletAddress}`);
          client.emit('connection_error', {
            message: 'Invalid wallet address format',
          });
        } else {
          client.join(`wallet:${walletAddress}`);
          this.logger.log(
            `Client ${clientId} joined wallet room: ${walletAddress}`,
          );
        }
      }

      // Set up custom error handler for this client
      client.on('error', (error) => {
        this.logger.error(`Error from client ${clientId}: ${error.message}`);
      });

      // Send connection acknowledged event
      client.emit('connection_ack', {
        id: clientId,
        timestamp: new Date().toISOString(),
        activeConnections: this.activeConnections,
      });
    } catch (error) {
      this.logger.error(
        'Error handling connection',
        error instanceof Error ? error.stack : String(error),
      );
    }
  }

  /**
   * Called when a client disconnects
   * @param client The disconnected client socket
   */
  handleDisconnect(client: Socket): void {
    try {
      this.activeConnections = Math.max(0, this.activeConnections - 1);

      // Clean up client subscriptions
      this.clientSubscriptions.delete(client.id);
      this.messageCounters.delete(client.id);

      this.logger.log(
        `Client disconnected: ${client.id} (${this.activeConnections} active connections)`,
      );
    } catch (error) {
      this.logger.error(
        'Error handling disconnection',
        error instanceof Error ? error.stack : String(error),
      );
    }
  }

  /**
   * Check if a client is being rate limited
   * @param clientId The client ID to check
   * @returns true if the client is rate limited, false otherwise
   */
  private isRateLimited(clientId: string): boolean {
    const now = Date.now();
    const clientCounter = this.messageCounters.get(clientId) || {
      count: 0,
      timestamp: now,
    };

    // Reset counter if it's been more than a minute
    if (now - clientCounter.timestamp > 60000) {
      clientCounter.count = 0;
      clientCounter.timestamp = now;
    }

    // Increment counter
    clientCounter.count++;
    this.messageCounters.set(clientId, clientCounter);

    // Check if over limit
    return clientCounter.count > this.maxMessagesPerMinute;
  }

  /**
   * Periodically clean up tracking for clients that might have disconnected without proper event
   */
  private cleanupInactiveClients(): void {
    try {
      const connectedSockets = this.server.sockets.sockets;
      const connectedIds = new Set([...connectedSockets.keys()]);

      // Clean up subscriptions for clients that no longer exist
      for (const clientId of this.clientSubscriptions.keys()) {
        if (!connectedIds.has(clientId)) {
          this.clientSubscriptions.delete(clientId);
          this.messageCounters.delete(clientId);
          this.logger.debug(
            `Cleaned up tracking for disconnected client: ${clientId}`,
          );
        }
      }
    } catch (error) {
      this.logger.error(
        'Error cleaning up inactive clients',
        error instanceof Error ? error.stack : String(error),
      );
    }
  }

  /**
   * Handle client subscribing to leaderboard updates
   * @param client The client socket
   * @param payload Optional subscription configuration
   * @returns Observable that emits subscription result
   */
  @SubscribeMessage('subscribe_leaderboard')
  @Throttle({ default: { limit: 5, ttl: 60000 } }) // Limit to 5 subscriptions per minute
  handleLeaderboardSubscription(
    @ConnectedSocket() client: Socket,
    @MessageBody() payload?: LeaderboardSubscription,
  ): Observable<WsResponse<{ success: boolean; message?: string }>> {
    try {
      // Check rate limiting
      if (this.isRateLimited(client.id)) {
        this.logger.warn(`Rate limit exceeded for client ${client.id}`);
        return from([
          {
            event: 'subscribe_leaderboard_result',
            data: { success: false, message: 'Rate limit exceeded' },
          },
        ]);
      }

      // Validate payload if provided
      let validatedPayload: LeaderboardSubscription | undefined;
      if (payload) {
        try {
          validatedPayload = LeaderboardSubscriptionSchema.parse(payload);
        } catch (error) {
          return from([
            {
              event: 'subscribe_leaderboard_result',
              data: {
                success: false,
                message: 'Invalid subscription parameters',
              },
            },
          ]);
        }
      }

      // Track this subscription
      const clientSubs = this.clientSubscriptions.get(client.id) || new Set();
      clientSubs.add('leaderboard');
      this.clientSubscriptions.set(client.id, clientSubs);

      // Join room with specific parameters if provided
      const roomName = validatedPayload?.timeFrame
        ? `leaderboard:${validatedPayload.timeFrame}:${validatedPayload.limit || 'all'}`
        : 'leaderboard';

      client.join(roomName);

      this.logger.log(`Client ${client.id} subscribed to ${roomName}`);

      // Return success response
      return from([
        {
          event: 'subscribe_leaderboard_result',
          data: {
            success: true,
            message: `Subscribed to ${roomName}`,
          },
        },
      ]);
    } catch (error) {
      this.logger.error(
        `Error in leaderboard subscription for client ${client.id}`,
        error instanceof Error ? error.stack : String(error),
      );
      return from([
        {
          event: 'subscribe_leaderboard_result',
          data: { success: false, message: 'Internal server error' },
        },
      ]);
    }
  }

  /**
   * Handle client unsubscribing from leaderboard updates
   * @param client The client socket
   * @param payload Optional unsubscription configuration
   */
  @SubscribeMessage('unsubscribe_leaderboard')
  handleLeaderboardUnsubscription(
    @ConnectedSocket() client: Socket,
    @MessageBody()
    payload?: {
      timeFrame?: 'daily' | 'weekly' | 'monthly' | 'all';
      limit?: number;
    },
  ): WsResponse<{ success: boolean }> {
    try {
      // Leave all leaderboard rooms or specific ones
      if (!payload) {
        // Get all rooms this client is in
        const rooms = [...client.rooms].filter(
          (room) => room !== client.id && room.startsWith('leaderboard'),
        );

        // Leave each room
        for (const room of rooms) {
          client.leave(room);
        }

        // Update tracking
        const clientSubs = this.clientSubscriptions.get(client.id);
        if (clientSubs) {
          clientSubs.delete('leaderboard');
          this.clientSubscriptions.set(client.id, clientSubs);
        }

        this.logger.log(
          `Client ${client.id} unsubscribed from all leaderboard updates`,
        );
      } else {
        // Leave specific room
        const roomName = payload.timeFrame
          ? `leaderboard:${payload.timeFrame}:${payload.limit || 'all'}`
          : 'leaderboard';

        client.leave(roomName);
        this.logger.log(`Client ${client.id} unsubscribed from ${roomName}`);
      }

      return {
        event: 'unsubscribe_leaderboard_result',
        data: { success: true },
      };
    } catch (error) {
      this.logger.error(
        `Error in leaderboard unsubscription for client ${client.id}`,
        error instanceof Error ? error.stack : String(error),
      );
      return {
        event: 'unsubscribe_leaderboard_result',
        data: { success: false },
      };
    }
  }

  /**
   * Broadcast a leaderboard update to all subscribed clients
   * @param data The updated leaderboard data
   * @param timeFrame The time frame for the leaderboard data
   * @param limit Optional limit for the number of entries
   */
  broadcastLeaderboardUpdate(
    data: LeaderboardUpdate,
    timeFrame: 'daily' | 'weekly' | 'monthly' | 'all' = 'all',
    limit?: number,
  ): void {
    try {
      const roomName = timeFrame
        ? `leaderboard:${timeFrame}:${limit || 'all'}`
        : 'leaderboard';

      this.server.to(roomName).emit('leaderboard_update', {
        ...data,
        timeFrame,
        updatedAt: new Date().toISOString(),
      });

      this.logger.log(
        `Broadcasted ${timeFrame} leaderboard update to ${roomName}`,
      );
    } catch (error) {
      this.logger.error(
        'Error broadcasting leaderboard update',
        error instanceof Error ? error.stack : String(error),
      );
    }
  }

  /**
   * Send a notification to a specific wallet address
   * @param walletAddress The wallet address to send to
   * @param notification The notification data to send
   */
  notifyWallet(walletAddress: string, notification: WalletNotification): void {
    try {
      if (!walletAddress || !/^0x[a-fA-F0-9]{40}$/.test(walletAddress)) {
        this.logger.warn(`Invalid wallet address format: ${walletAddress}`);
        return;
      }

      this.server.to(`wallet:${walletAddress}`).emit('wallet_notification', {
        ...notification,
        timestamp: notification.timestamp || new Date().toISOString(),
      });

      this.logger.log(
        `Sent ${notification.type} notification to wallet ${walletAddress}`,
      );
    } catch (error) {
      this.logger.error(
        `Error sending notification to wallet ${walletAddress}`,
        error instanceof Error ? error.stack : String(error),
      );
    }
  }

  /**
   * Broadcast a message to all connected clients
   * @param event The event name
   * @param data The message data
   * @param namespace Optional namespace to broadcast to
   */
  broadcastToAll<T>(event: string, data: T, namespace?: string): void {
    try {
      if (namespace) {
        this.server.of(namespace).emit(event, data);
      } else {
        this.server.emit(event, data);
      }

      this.logger.log(
        `Broadcasted ${event} to all clients${namespace ? ` in namespace ${namespace}` : ''}`,
      );
    } catch (error) {
      this.logger.error(
        `Error broadcasting to all clients: ${event}`,
        error instanceof Error ? error.stack : String(error),
      );
    }
  }

  /**
   * Get current gateway stats
   * @returns Object with current stats
   */
  getStats(): Record<string, unknown> {
    return {
      activeConnections: this.activeConnections,
      roomStats: Object.fromEntries(
        [...this.server.sockets.adapter.rooms.entries()]
          .filter(
            ([room]) => room.includes('leaderboard') || room.includes('wallet'),
          )
          .map(([room, clients]) => [room, clients.size]),
      ),
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Check if the WebSocket server is active
   * @returns boolean indicating if the server is initialized and running
   */
  isActive(): boolean {
    // Generated by Copilot
    return !!this.server && this.activeConnections >= 0;
  }
}
