interface DeepSeekResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
}

interface GenerationRequest {
  websiteType: string;
  content: string;
  colorScheme?: string;
  fontFamily?: string;
  ethiopianSupport?: boolean;
  rtlSupport?: boolean;
}

export class DeepSeekService {
  private apiKey: string;
  private baseUrl = "https://api.deepseek.com/v1/chat/completions";

  constructor() {
    this.apiKey = process.env.DEEPSEEK_API_KEY || "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";
  }

  async generateWebsite(request: GenerationRequest): Promise<{
    html: string;
    css: string;
    js: string;
  }> {
    const prompt = this.buildPrompt(request);
    
    try {
      const response = await fetch(this.baseUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify({
          model: "deepseek-chat",
          messages: [
            {
              role: "system",
              content: "You are an expert web developer specializing in creating modern, responsive websites using HTML5, Tailwind CSS, and vanilla JavaScript. Generate clean, semantic, production-ready code."
            },
            {
              role: "user",
              content: prompt
            }
          ],
          temperature: 0.7,
          max_tokens: 4000,
        }),
      });

      if (!response.ok) {
        throw new Error(`DeepSeek API error: ${response.status} ${response.statusText}`);
      }

      const data: DeepSeekResponse = await response.json();
      const generatedContent = data.choices[0]?.message?.content;

      if (!generatedContent) {
        throw new Error("No content generated by DeepSeek API");
      }

      return this.parseGeneratedContent(generatedContent);
    } catch (error) {
      console.error("DeepSeek API error:", error);
      throw new Error(`Failed to generate website: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }

  private buildPrompt(request: GenerationRequest): string {
    const { websiteType, content, colorScheme, fontFamily, ethiopianSupport, rtlSupport } = request;
    
    let prompt = `Create a complete, production-ready website for a ${websiteType} business. 

Content to include:
${content}

Requirements:
- Use modern HTML5 semantic structure
- Implement responsive design with Tailwind CSS v3.4+
- Create a mobile-first approach
- Include a responsive navbar with logo area
- Add a compelling hero section
- Structure content in organized sections
- Include a contact form
- Add basic JavaScript for interactivity (mobile menu, form validation, smooth scrolling)
- Use clean, semantic HTML without !important CSS rules
- No inline styles, only Tailwind classes
`;

    if (colorScheme) {
      prompt += `- Use ${colorScheme} as the primary color scheme\n`;
    }

    if (fontFamily) {
      prompt += `- Use ${fontFamily} font family\n`;
    }

    if (ethiopianSupport) {
      prompt += `- Include Abyssinica SIL font for Amharic text support\n`;
      prompt += `- Add proper Unicode support for Ethiopian characters\n`;
    }

    if (rtlSupport) {
      prompt += `- Include RTL (right-to-left) layout support\n`;
      prompt += `- Add proper text direction classes\n`;
    }

    prompt += `
Structure your response EXACTLY as follows:

HTML:
[Complete HTML code here]

CSS:
[Additional custom CSS if needed, otherwise just include Tailwind CDN]

JS:
[Complete JavaScript code for interactivity]

Make sure the website is visually appealing, professional, and fully functional.`;

    return prompt;
  }

  private parseGeneratedContent(content: string): {
    html: string;
    css: string;
    js: string;
  } {
    // Extract HTML section
    const htmlMatch = content.match(/HTML:\s*([\s\S]*?)(?=CSS:|JS:|$)/i);
    const html = htmlMatch ? htmlMatch[1].trim() : "";

    // Extract CSS section
    const cssMatch = content.match(/CSS:\s*([\s\S]*?)(?=JS:|$)/i);
    const css = cssMatch ? cssMatch[1].trim() : "";

    // Extract JS section
    const jsMatch = content.match(/JS:\s*([\s\S]*?)$/i);
    const js = jsMatch ? jsMatch[1].trim() : "";

    // Fallback: if sections aren't clearly marked, try to extract from code blocks
    if (!html && !css && !js) {
      const codeBlocks = content.match(/```[\s\S]*?```/g) || [];
      return {
        html: codeBlocks[0]?.replace(/```html?|```/g, "").trim() || content,
        css: codeBlocks[1]?.replace(/```css?|```/g, "").trim() || "",
        js: codeBlocks[2]?.replace(/```js?|javascript|```/g, "").trim() || "",
      };
    }

    return { html, css, js };
  }
}

export const deepSeekService = new DeepSeekService();
