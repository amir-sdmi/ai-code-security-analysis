// Generated by Copilot
import autoload from '@fastify/autoload';
import compress from '@fastify/compress';
import cors from '@fastify/cors';
import env from '@fastify/env';
import etag from '@fastify/etag';
import helmet from '@fastify/helmet';
import jwt from '@fastify/jwt';
import multipart from '@fastify/multipart';
import rateLimit from '@fastify/rate-limit';
import redis from '@fastify/redis';
import staticFiles from '@fastify/static';
import underPressure from '@fastify/under-pressure';
import Fastify, { FastifyInstance, FastifyServerOptions } from 'fastify';
import path from 'path';

// Import custom plugins, hooks and services
import requestContextHook from './hooks/request-context.hook';
import monitoringPlugin from './plugins/monitoring.plugin';
import { IntegrationService } from './services/integration.service';

/**
 * Schema for environment variables
 */
const envSchema = {
  type: 'object',
  required: ['PORT', 'HOST', 'JWT_SECRET'],
  properties: {
    NODE_ENV: {
      type: 'string',
      default: 'development',
    },
    PORT: {
      type: 'string',
      default: '3100',
    },
    HOST: {
      type: 'string',
      default: '0.0.0.0',
    },
    REDIS_URL: {
      type: 'string',
    },
    JWT_SECRET: {
      type: 'string',
    },
    RATE_LIMIT: {
      type: 'number',
      default: 100,
    },
    RATE_LIMIT_TIMEWINDOW: {
      type: 'string',
      default: '1 minute',
    },
    API_PREFIX: {
      type: 'string',
      default: '/api/v1',
    },
    ENABLE_SWAGGER: {
      type: 'boolean',
      default: true,
    },
    MAX_PAYLOAD_SIZE: {
      type: 'string',
      default: '5mb',
    },
  },
};

/**
 * Creates and configures a Fastify server instance with all required plugins
 * @param options - Fastify server options
 * @returns Configured Fastify instance
 */
export async function createServer(
  options: FastifyServerOptions = {},
): Promise<FastifyInstance> {
  const fastify = Fastify({
    // Use Pino for structured logging with correlation IDs
    logger: {
      level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
      transport:
        process.env.NODE_ENV !== 'production'
          ? {
              target: 'pino-pretty',
              options: {
                translateTime: 'HH:MM:ss Z',
                ignore: 'pid,hostname',
                colorize: true,
              },
            }
          : undefined,
      serializers: {
        req(request) {
          return {
            method: request.method,
            url: request.url,
            hostname: request.hostname,
            remoteAddress: request.ip,
            remotePort: request.socket?.remotePort,
          };
        },
      },
    },
    // Performance options
    disableRequestLogging: true, // We handle this in our hook
    ignoreTrailingSlash: true,
    connectionTimeout: 30000, // 30 seconds
    keepAliveTimeout: 30000, // 30 seconds
    maxParamLength: 150,
    bodyLimit: parseInt(process.env.MAX_PAYLOAD_SIZE || '5242880', 10), // Default 5MB
    trustProxy: true,
    ...options,
  });

  try {
    // Load environment configuration
    await fastify.register(env, {
      schema: envSchema,
      dotenv: true,
      data: process.env,
    });

    // Core security features
    await fastify.register(helmet, {
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: ["'self'", "'unsafe-inline'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          imgSrc: ["'self'", 'data:', 'validator.swagger.io'],
          connectSrc: ["'self'", 'https://*.wikiflow.com'],
        },
      },
    });

    await fastify.register(cors, {
      origin: [
        'https://wikiflow.com',
        'https://*.wikiflow.com',
        'http://localhost:3000',
      ],
      methods: ['GET', 'PUT', 'POST', 'DELETE', 'OPTIONS', 'PATCH'],
      credentials: true,
      maxAge: 86400, // 24 hours
    });

    // Performance optimizations
    await fastify.register(compress, {
      threshold: 1024, // Only compress responses larger than 1KB
      encodings: ['gzip', 'deflate', 'br'],
    });
    await fastify.register(etag);

    // API rate limiting
    if (process.env.NODE_ENV === 'production') {
      await fastify.register(rateLimit, {
        max: fastify.config.RATE_LIMIT,
        timeWindow: fastify.config.RATE_LIMIT_TIMEWINDOW,
        redis: fastify.redis,
        // Add whitelist for internal services
        whitelist: (req) => {
          const apiKey = req.headers['x-api-key'];
          return apiKey === process.env.INTERNAL_API_KEY;
        },
        keyGenerator: (req) => {
          // Use authId if authenticated, otherwise IP
          return req.user?.id || req.ip;
        },
      });
    }

    // Advanced load monitoring
    await fastify.register(underPressure, {
      maxEventLoopDelay: 1000, // 1 second
      maxHeapUsedBytes: 1000000000, // ~1GB
      maxRssBytes: 1500000000, // ~1.5GB
      pressureHandler: (req, rep, type, value) => {
        fastify.log.warn(`Server under pressure: ${type} ${value}`);
        return rep.code(503).send({
          error: 'Service Unavailable',
          message: 'Server is under high load, please try again later',
          statusCode: 503,
        });
      },
    });

    // Redis support if configured
    if (fastify.config.REDIS_URL) {
      await fastify.register(redis, {
        url: fastify.config.REDIS_URL,
        closeClient: true,
      });
      fastify.log.info('Redis connected');
    }

    // Authentication support
    await fastify.register(jwt, {
      secret: fastify.config.JWT_SECRET,
      sign: {
        expiresIn: '24h',
      },
    });

    // Add support for multipart/form-data
    await fastify.register(multipart, {
      limits: {
        fieldNameSize: 100, // Max field name size in bytes
        fieldSize: 1000000, // Max field value size in bytes (1MB)
        fields: 20, // Max number of non-file fields
        fileSize: 10000000, // 10MB max file size
        files: 5, // Max number of file fields
        headerPairs: 100, // Max number of header key-value pairs
      },
    });

    // Static file serving for public assets
    await fastify.register(staticFiles, {
      root: path.join(__dirname, '..', '..', 'public'),
      prefix: '/public/',
      decorateReply: false,
      cacheControl: true,
      maxAge: 86400 * 30, // 30 days
      immutable: true,
      etag: true,
    });

    // Register custom plugins, hooks and services
    await fastify.register(monitoringPlugin);
    await fastify.register(requestContextHook);

    // Register integration service with cache layer
    await IntegrationService.init(fastify);
    IntegrationService.registerCacheService(fastify);

    // Auto-load all routes from the routes directory
    await fastify.register(autoload, {
      dir: path.join(__dirname, 'routes'),
      dirNameRoutePrefix: true, // Use directory names as route prefixes
      ignorePattern: /(spec|test)\.(ts|js)$/i, // Ignore test files
      autoHooks: true, // Automatically load hooks from each directory
      cascadeHooks: true, // Hooks cascade to child routes
      options: {
        prefix: fastify.config.API_PREFIX, // Add /api/v1 prefix to all routes
      },
    });

    // Global error handler for consistent error responses
    fastify.setErrorHandler((error, request, reply) => {
      const requestId = request.routeContext?.requestId || 'unknown';

      // Log the error with context
      fastify.log.error({
        requestId,
        err: error,
        msg: 'Unhandled error',
        path: request.url,
        method: request.method,
      });

      // Determine appropriate status code
      let statusCode = error.statusCode || 500;
      if (error.validation) {
        statusCode = 400;
      }

      // Format error response
      const errorResponse = {
        error: error.name || 'InternalServerError',
        message: error.message || 'An unexpected error occurred',
        statusCode,
        requestId,
      };

      // Don't expose stack traces in production
      if (process.env.NODE_ENV !== 'production' && error.stack) {
        // @ts-ignore - for development debugging only
        errorResponse.stack = error.stack;
      }

      reply.status(statusCode).send(errorResponse);
    });

    // Not found handler
    fastify.setNotFoundHandler((request, reply) => {
      reply.status(404).send({
        error: 'NotFound',
        message: `Route ${request.method}:${request.url} not found`,
        statusCode: 404,
        requestId: request.routeContext?.requestId || 'unknown',
      });
    });

    // Register health check route
    fastify.get('/health', async () => {
      return {
        status: 'ok',
        timestamp: Date.now(),
        uptime: process.uptime(),
        version: process.env.npm_package_version || '1.0.0',
      };
    });

    // Add graceful shutdown
    const closeListeners = [];

    // Stop accepting new connections, finish existing ones
    process.on('SIGTERM', async () => {
      fastify.log.info('SIGTERM received, shutting down gracefully');

      // Execute registered cleanup handlers
      for (const listener of closeListeners) {
        try {
          await listener();
        } catch (err) {
          fastify.log.error(`Error during shutdown: ${err.message}`);
        }
      }

      // Close the server with a 30s timeout
      await fastify.close(30000);
      process.exit(0);
    });

    // Register a shutdown listener
    fastify.decorate('addShutdownListener', (listener) => {
      closeListeners.push(listener);
    });

    fastify.log.info(
      `Fastify server configured in ${process.env.NODE_ENV} mode`,
    );
    return fastify;
  } catch (err) {
    fastify.log.error(`Error setting up Fastify server: ${err.message}`);
    throw err;
  }
}

/**
 * Start the Fastify server
 */
export async function startServer(): Promise<void> {
  try {
    const server = await createServer();
    const PORT = server.config.PORT;
    const HOST = server.config.HOST;

    await server.listen({ port: parseInt(PORT, 10), host: HOST });
    server.log.info(`Server listening on ${HOST}:${PORT}`);

    // Log start-up metrics
    const memUsage = process.memoryUsage();
    server.log.info({
      msg: 'Server startup complete',
      memoryUsage: {
        rss: `${Math.round(memUsage.rss / 1024 / 1024)} MB`,
        heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)} MB`,
        heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)} MB`,
      },
      nodeVersion: process.version,
    });
  } catch (err) {
    console.error('Fatal error starting server:', err);
    process.exit(1);
  }
}

// Allow direct execution
if (require.main === module) {
  startServer();
}
