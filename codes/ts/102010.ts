// Generated by Copilot
import {
  Injectable,
  Logger,
  OnModuleDestroy,
  OnModuleInit,
} from '@nestjs/common';
import Database from 'better-sqlite3';
import type { BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
import type { PostgresJsDatabase } from 'drizzle-orm/postgres-js';
import { drizzle as drizzlePg } from 'drizzle-orm/postgres-js';
import { migrate as migratePg } from 'drizzle-orm/postgres-js/migrator';
import { access, mkdir } from 'fs/promises';
import { join } from 'path';
import postgres from 'postgres';
import * as schema from '../../../drizzle/schema';

// Define union type for database instance
type DrizzleDB =
  | BetterSQLite3Database<typeof schema>
  | PostgresJsDatabase<typeof schema>;

/**
 * Service that provides Drizzle ORM connection
 * Supports both SQLite and PostgreSQL based on environment variables
 * Enhanced with connection pooling, auto-migrations, and better typing
 */
@Injectable()
export class DrizzleService implements OnModuleInit, OnModuleDestroy {
  private db: DrizzleDB | null = null;
  private pgClient: ReturnType<typeof postgres> | null = null;
  private sqliteClient: Database.Database | null = null;
  private readonly databaseType: 'sqlite' | 'postgres';
  private readonly databaseUrl: string;
  private readonly logger = new Logger(DrizzleService.name);
  private connectionRetries = 0;
  private readonly maxRetries = 5;

  constructor() {
    // Using environment variables with defaults
    this.databaseType = (process.env.DATABASE_TYPE || 'sqlite') as
      | 'sqlite'
      | 'postgres';
    this.databaseUrl =
      process.env.DATABASE_URL || 'sqlite://./data/wikiflow.db';
    this.logger.log(`Using database type: ${this.databaseType}`);
  }

  /**
   * Initialize database connection when the module starts
   * Includes automatic retry logic
   */
  async onModuleInit(): Promise<void> {
    try {
      if (this.databaseType === 'postgres') {
        await this.initPostgres();
      } else {
        await this.initSqlite();
      }

      // Run automatic migrations if enabled
      if (process.env.AUTO_MIGRATE === 'true') {
        await this.runMigrations();
      }

      this.logger.log('Database connection established successfully');
    } catch (error) {
      this.connectionRetries++;

      if (this.connectionRetries <= this.maxRetries) {
        const retryDelay = Math.min(1000 * 2 ** this.connectionRetries, 30000);
        this.logger.warn(
          `Failed to initialize database (attempt ${this.connectionRetries}/${this.maxRetries}). Retrying in ${retryDelay / 1000}s...`,
        );

        // Retry with exponential backoff
        setTimeout(() => this.onModuleInit(), retryDelay);
      } else {
        this.logger.error(
          'Failed to initialize database after multiple attempts',
          error instanceof Error ? error.stack : String(error),
        );
        throw error;
      }
    }
  }

  /**
   * Initialize SQLite database with optimized settings
   */
  private async initSqlite(): Promise<void> {
    const dbPath = this.databaseUrl.replace('sqlite://', '');

    // Create the data directory if it doesn't exist
    try {
      const dirPath = join(process.cwd(), 'data');
      await mkdir(dirPath, { recursive: true });
    } catch (error) {
      // Ignore error if directory already exists
      if (
        error instanceof Error &&
        'code' in error &&
        error.code !== 'EEXIST'
      ) {
        throw error;
      }
    }

    // Connect to SQLite database with optimized settings
    try {
      const sqlite = new Database(dbPath, {
        // Performance optimizations
        fileMustExist: false,
        timeout: 5000, // 5 seconds
        verbose:
          process.env.NODE_ENV === 'development' ? console.log : undefined,
      });

      // Enable optimizations
      sqlite.pragma('journal_mode = WAL'); // Write-Ahead Logging for better concurrency
      sqlite.pragma('synchronous = NORMAL'); // Decent compromise between safety and speed
      sqlite.pragma('foreign_keys = ON'); // Enable foreign key constraints
      sqlite.pragma('cache_size = -64000'); // 64MB cache size (negative means kilobytes)

      this.sqliteClient = sqlite;
      this.db = drizzle(sqlite, {
        schema,
        logger: process.env.NODE_ENV === 'development',
      });

      this.logger.log(
        `Connected to SQLite database at ${dbPath} with optimized settings`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to connect to SQLite database at ${dbPath}`,
        error instanceof Error ? error.stack : String(error),
      );
      throw error;
    }
  }

  /**
   * Initialize PostgreSQL database with connection pooling
   */
  private async initPostgres(): Promise<void> {
    try {
      // Check if the database is reachable before attempting connection
      const connectionOptions = {
        max: 10, // Maximum connections in pool
        idle_timeout: 20, // Close idle connections after 20 seconds
        connect_timeout: 10, // 10 second connection timeout
        prepare: true, // Auto-prepare statements for better performance
        types: {
          date: {
            to: 1184,
            from: [1082, 1083, 1114, 1184],
            serialize: (date: Date) => date.toISOString(),
            parse: (str: string) => new Date(str),
          },
        },
      };

      this.pgClient = postgres(this.databaseUrl, connectionOptions);

      // Test the connection
      await this.pgClient`SELECT 1`;

      this.db = drizzlePg(this.pgClient, {
        schema,
        logger: process.env.NODE_ENV === 'development',
      });

      this.logger.log(
        'Connected to PostgreSQL database with connection pooling',
      );
    } catch (error) {
      this.logger.error(
        'Failed to connect to PostgreSQL database',
        error instanceof Error ? error.stack : String(error),
      );
      if (this.pgClient) {
        await this.pgClient.end();
        this.pgClient = null;
      }
      throw error;
    }
  }

  /**
   * Run database migrations automatically
   */
  private async runMigrations(): Promise<void> {
    try {
      const migrationsPath = join(process.cwd(), '../drizzle/migrations');

      // Check if migrations directory exists
      try {
        await access(migrationsPath);
      } catch (error) {
        this.logger.warn(
          `Migrations directory not found at ${migrationsPath}. Skipping migrations.`,
        );
        return;
      }

      if (this.databaseType === 'postgres' && this.db) {
        this.logger.log('Running PostgreSQL migrations...');
        await migratePg(this.db as PostgresJsDatabase<typeof schema>, {
          migrationsFolder: migrationsPath,
        });
      } else if (this.db) {
        this.logger.log('Running SQLite migrations...');
        await migrate(this.db as BetterSQLite3Database<typeof schema>, {
          migrationsFolder: migrationsPath,
        });
      }

      this.logger.log('Database migrations completed successfully');
    } catch (error) {
      this.logger.error(
        'Failed to run database migrations',
        error instanceof Error ? error.stack : String(error),
      );
      throw error;
    }
  }

  /**
   * Get the Drizzle ORM instance with proper typing
   */
  get orm(): DrizzleDB {
    if (!this.db) {
      throw new Error(
        'Database not initialized. Make sure to wait for onModuleInit() to complete.',
      );
    }
    return this.db;
  }

  /**
   * Check database health
   */
  async healthCheck(): Promise<boolean> {
    try {
      if (this.databaseType === 'postgres' && this.pgClient) {
        await this.pgClient`SELECT 1`;
      } else if (this.sqliteClient) {
        this.sqliteClient.prepare('SELECT 1').get();
      } else {
        return false;
      }
      return true;
    } catch (error) {
      this.logger.error(
        'Database health check failed',
        error instanceof Error ? error.stack : String(error),
      );
      return false;
    }
  }

  /**
   * Close database connections when the module is destroyed
   */
  async onModuleDestroy(): Promise<void> {
    try {
      if (this.databaseType === 'postgres' && this.pgClient) {
        await this.pgClient.end({ timeout: 5 });
        this.pgClient = null;
        this.logger.log('PostgreSQL connection closed');
      } else if (this.sqliteClient) {
        this.sqliteClient.close();
        this.sqliteClient = null;
        this.logger.log('SQLite connection closed');
      }
    } catch (error) {
      this.logger.error(
        'Error closing database connection',
        error instanceof Error ? error.stack : String(error),
      );
    } finally {
      this.db = null;
    }
  }
}
