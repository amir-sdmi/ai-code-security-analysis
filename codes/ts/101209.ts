// Note. Below code is generated by ChatGPT 3.5

// Example: Online Shopping System

// Information Expert
// @ts-ignore
class Product {
  constructor(public name: string, public price: number) { }

  // Information Expert: Get product details
  getProductDetails(): string {
    return `Product: ${this.name}, Price: $${this.price}`;
  }
}

// Creator
// @ts-ignore
class ShoppingCart {
  // Creator: ShoppingCart creates an instance of Product
  addItemToCart(product: Product, quantity: number): void {
    // Logic to add the product to the shopping cart
    console.log(`Added ${quantity} ${product.name}(s) to the shopping cart.`);
  }
}

// Controller
class OrderController {
  // Controller: Manages the flow of order processing
  processOrder(cart: ShoppingCart): void {
    // Logic to process the order
    console.log('Processing order...');
    // Additional logic for order processing
  }
}

// Low Coupling and High Cohesion
// @ts-ignore
class Customer {
  constructor(public name: string) { }

  // High Cohesion: Customer-related responsibilities
  placeOrder(cart: ShoppingCart, orderController: OrderController): void {
    // Logic to place an order
    console.log(`Customer ${this.name} is placing an order.`);

    // Low Coupling: Customer delegates order processing to OrderController
    orderController.processOrder(cart);
  }
}

// Pure Fabrication
class EmailService {
  // Pure Fabrication: Provides a service not directly related to the problem domain
  sendOrderConfirmationEmail(customer: Customer): void {
    // Logic to send order confirmation email
    console.log(`Order confirmation email sent to ${customer.name}.`);
  }
}

// Indirection
class OrderProcessor {
  // Indirection: Mediates between Customer, ShoppingCart, and EmailService
  processOrder(customer: Customer, cart: ShoppingCart, emailService: EmailService): void {
    // Logic to coordinate order processing
    customer.placeOrder(cart, new OrderController());

    // Additional logic

    // Low Coupling: Indirection minimizes direct dependencies between classes
    emailService.sendOrderConfirmationEmail(customer);
  }
}

// Usage example
const product1 = new Product('Laptop', 999.99);
const product2 = new Product('Headphones', 49.99);

const cart = new ShoppingCart();
cart.addItemToCart(product1, 2);
cart.addItemToCart(product2, 1);

const customer = new Customer('John Doe');
const emailService = new EmailService();
const orderProcessor = new OrderProcessor();

// Process the order
orderProcessor.processOrder(customer, cart, emailService);


/*
This example illustrates how some of the GRASP principles are applied:

- Information Expert: The Product class holds information about a product and is responsible for providing details about itself.
- Creator: The ShoppingCart class creates instances of Product when items are added to the cart.
- Controller: The OrderController class manages the flow of order processing.
- Low Coupling and High Cohesion: The Customer class has high cohesion as it is responsible for customer-related activities, and low coupling as it delegates order processing to the OrderController.
- Pure Fabrication: The EmailService class is a pure fabrication, providing a service not directly related to the problem domain.
- Indirection: The OrderProcessor class acts as an intermediary, coordinating order processing between Customer, ShoppingCart, and EmailService, reducing direct dependencies between these classes.

*/
