/**
 * Generated by Copilot
 *
 * Safe utilities for handling BigInt operations, with additional
 * safety checks to prevent buffer overflow vulnerabilities.
 * This provides an extra layer of security beyond the patched bigint-buffer package.
 */

/**
 * Safely converts a Buffer to a BigInt with size validation and error handling
 * @param {Buffer} buf - The buffer to convert
 * @param {boolean} isLittleEndian - Whether the buffer is in little endian format
 * @param {number} maxByteSize - Maximum safe byte size to process
 * @returns {BigInt} The converted BigInt
 * @throws {Error} If buffer exceeds safe size limits
 */
export const safeBufferToBigInt = (
  buf: Buffer,
  isLittleEndian: boolean = true,
  maxByteSize: number = 8192, // Reasonable upper limit
): bigint => {
  try {
    // Safety check to prevent DoS via large buffer processing
    if (!buf || buf.length === 0) {
      throw new Error('Empty or invalid buffer provided');
    }

    if (buf.length > maxByteSize) {
      throw new Error(
        `Buffer size (${buf.length} bytes) exceeds safe limit (${maxByteSize} bytes)`,
      );
    }

    // Defensive copy to prevent mutation during processing
    const safeBuf = Buffer.from(buf);

    // Use native BigInt constructor with toString for max safety
    const hex = safeBuf.toString('hex');
    return BigInt(`0x${hex}`);
  } catch (error) {
    console.error('Error in safeBufferToBigInt:', error);
    throw error;
  }
};

/**
 * Safely converts a BigInt to a Buffer with size validation
 * @param {BigInt} num - The BigInt to convert
 * @param {number} byteLength - The desired byte length
 * @param {boolean} isLittleEndian - Whether to use little endian format
 * @returns {Buffer} The resulting buffer
 * @throws {Error} If operation could cause buffer overflow
 */
export const safeBigIntToBuffer = (
  num: bigint,
  byteLength: number,
  isLittleEndian: boolean = true,
): Buffer => {
  try {
    // Validate inputs
    if (byteLength <= 0 || byteLength > 8192) {
      throw new Error(`Invalid byte length: ${byteLength}`);
    }

    // Check if BigInt is negative
    if (num < 0n) {
      throw new Error('Negative BigInt values are not supported');
    }

    // Convert to hex string
    let hex = num.toString(16);

    // Pad to even length
    if (hex.length % 2) {
      hex = '0' + hex;
    }

    // Ensure the number fits in the specified byte length
    if (hex.length / 2 > byteLength) {
      throw new Error(
        `BigInt ${num} exceeds specified byte length ${byteLength}`,
      );
    }

    // Create buffer from hex string
    const buf = Buffer.from(hex.padStart(byteLength * 2, '0'), 'hex');

    // Return in requested endianness
    return isLittleEndian ? buf.reverse() : buf;
  } catch (error) {
    console.error('Error in safeBigIntToBuffer:', error);
    throw error;
  }
};

/**
 * Performs a safety check on buffers before operations
 * @param {Buffer} buffer - The buffer to check
 * @param {number} maxSize - Maximum allowed size in bytes
 * @returns {boolean} True if buffer passes safety checks
 * @throws {Error} If buffer fails safety checks
 */
export const validateBufferSafety = (
  buffer: Buffer,
  maxSize: number = 8192,
): boolean => {
  if (!Buffer.isBuffer(buffer)) {
    throw new Error('Not a valid buffer');
  }

  if (buffer.length === 0) {
    throw new Error('Empty buffer provided');
  }

  if (buffer.length > maxSize) {
    throw new Error(
      `Buffer size ${buffer.length} exceeds maximum safe size ${maxSize}`,
    );
  }

  return true;
};

/**
 * Safely performs BigInt arithmetic with overflow protection
 * @param {BigInt} a - First operand
 * @param {BigInt} b - Second operand
 * @param {Function} operation - The arithmetic operation to perform
 * @returns {BigInt} Result of the operation
 */
export const safeBigIntOperation = (
  a: bigint,
  b: bigint,
  operation: (x: bigint, y: bigint) => bigint,
): bigint => {
  try {
    // Convert to BigInt to ensure we're working with the right type
    const aBigInt = BigInt(a);
    const bBigInt = BigInt(b);

    return operation(aBigInt, bBigInt);
  } catch (error) {
    console.error('Error in safeBigIntOperation:', error);
    throw error;
  }
};
