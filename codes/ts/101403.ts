/**
 * Returns an integer between a range.
 * Inspired by "random" python library - made by [PwlDev](https://github.com/PwLDev).
 */
export function randInt(min: number, max: number) {
    return (Math.floor(Math.random() * (max - min)) + min);
}

export function choices<T>(
    population: T[], 
    weights: number | number[] | null = null,
    cum_weights: number | number[] | null = null,
    k: number = 1
) {
    let n = population.length;

    if (cum_weights === null && weights === null) {
        const array: T[] = [];
        for (let i = 0; i < k; i++) {
            array.push(population[Math.floor(Math.random() * n)]);
        }
        return array;
    }

    if (cum_weights === null && weights !== null) {
        if (!Array.isArray(weights)) {
            if (typeof weights === "number") {
                k = weights;
                throw new TypeError(`The number of choices must be a keyword argument: k=${k}`);
            }
            throw new TypeError("weights must be an array of numbers");
        }

        let cw: number[] = [];
        weights.reduce((acc, val) => {
            if (typeof val !== "number") {
                throw new TypeError("All weights must be numbers");
            }
            const total = acc + val;
            cw.push(total);
            return total;
        }, 0);
        cum_weights = cw;
    }

    if (!Array.isArray(cum_weights) || cum_weights.length !== n) {
        throw new Error(`The number of weights must match the population`);
    }

    const total = (cum_weights as number[]).at(-1)! + 0.0;

    if (total <= 0.0) {
        throw new Error(`Total of weights must be greater than zero`)
    }

    if (!Number.isFinite(total)) {
        throw new Error(`Total of weights must be finite`)
    }

    const hi = n - 1;

    const array: T[] = []
    for (let i = 0; i < k; i++) {
        const idx = bisect(cum_weights as number[], Math.random() * total, 0, hi);
        array.push(population[idx]);
    }

    return array;
}

function bisect(
    a: number[],
    x: number,
    lo: number = 0,
    hi: number | null = null,
    key: ((el: number) => number) | null = null
) {
    if (lo < 0) {
        throw new Error(`lo must be non-negative`)
    }

    if (hi === null) {
        hi = a.length;
    }

    if (key === null) {
        while (lo < hi) {
            const mid = Math.floor((lo + hi) / 2);
            if (x < a[mid]) {
                hi = mid
            } else {
                lo = mid + 1;
            }
        }
    } else {
        while (lo < hi) {
            const mid = Math.floor((lo + hi) / 2);
            if (x < key(a[mid])) {
                hi = mid
            } else {
                lo = mid + 1;
            }
        }
    }

    return lo;
}

/**
 * Retuners an array of random elements
 * Inspired by "random" python library - generated by Gemini
 */
export function shuffle<T>(array: T[], n: number): T[] {
    if (n > array.length) {
        throw new Error("Sample size cannot be greater than array length");
    }
    
    const shuffled = array.slice();
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    
    return shuffled.slice(0, n);
}