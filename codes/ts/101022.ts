import {reduceToMap, runSingleTestCase, TestSuite} from '../../_main';

export type Input<T = any> = {
	array: T[];
	keyResolver: (item: T, index: number) => any;
	mapper: (item: T, index: number) => any;
	map?: {[key: string]: any};
};

export type Result = any;
export type TestSuite_reduceToMap = TestSuite<Input, Result>;
export type TestCase_reduceToMap = TestSuite_reduceToMap['testcases'][number];

const test = async (input: Input): Promise<Result> => {
	return reduceToMap(input.array, input.keyResolver, input.mapper, input.map || {});
};

const runTestCase = (testCase: TestCase_reduceToMap) => {
	return () => runSingleTestCase(test, testCase);
};

describe('reduceToMap', () => {
	it('Creates name-to-age map from object array', runTestCase({
		input: {
			array: [{name: 'Alon', age: 27}, {name: 'Itay', age: 28}],
			keyResolver: item => item.name,
			mapper: item => item.age
		},
		result: {Alon: 27, Itay: 28}
	}));

	it('Indexes string array by value, maps to index', runTestCase({
		input: {
			array: ['Alon', 'Itay'],
			keyResolver: item => item,
			mapper: (_item, index) => index
		},
		result: {Alon: 0, Itay: 1}
	}));

	// Generated by ChatGPT - 2025-05-25T23:00
	it('GPT - Starts from existing map and extends it', runTestCase({
		input: {
			array: ['C', 'D'],
			keyResolver: item => item,
			mapper: (_item, i) => i + 2,
			map: {A: 0, B: 1}
		},
		result: {A: 0, B: 1, C: 2, D: 3}
	}));

	// Generated by ChatGPT - 2025-05-25T23:00
	it('GPT - Uses index as key, maps to uppercase', runTestCase({
		input: {
			array: ['a', 'b', 'c'],
			keyResolver: (_item, i) => i,
			mapper: item => item.toUpperCase()
		},
		result: {0: 'A', 1: 'B', 2: 'C'}
	}));

	// Generated by ChatGPT - 2025-05-25T23:00
	it('GPT - Handles empty input array gracefully', runTestCase({
		input: {
			array: [],
			keyResolver: item => item,
			mapper: item => item
		},
		result: {}
	}));

	// Generated by ChatGPT - 2025-05-25T23:00
	it('GPT - Last value wins when keys collide', runTestCase({
		input: {
			array: ['a', 'a', 'a'],
			keyResolver: item => item,
			mapper: (_item, i) => i
		},
		result: {a: 2}
	}));
});
