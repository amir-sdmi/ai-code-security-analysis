// Generated by Copilot
import {
  FastifyInstance,
  FastifyPluginAsync,
  FastifyReply,
  FastifyRequest,
} from 'fastify';
import fp from 'fastify-plugin';
import { PerformanceMetrics } from '../types/fastify.d';

/**
 * Advanced monitoring plugin for Fastify with real-time metrics tracking
 * and performance analytics
 */
const monitoringPlugin: FastifyPluginAsync = async (
  fastify: FastifyInstance,
) => {
  // Initialize metrics storage
  const metrics: PerformanceMetrics = {
    requestCount: 0,
    responseTime: {
      avg: 0,
      min: Infinity,
      max: 0,
      p95: 0,
      p99: 0,
    },
    errorRate: 0,
    memoryUsage: {
      rss: 0,
      heapTotal: 0,
      heapUsed: 0,
      external: 0,
    },
    cpuUsage: 0,
  };

  // Store response times to calculate percentiles
  const responseTimes: number[] = [];
  const errorCounts: { [key: number]: number } = {};
  let totalErrors = 0;

  // Calculate percentiles function
  const calculatePercentile = (
    values: number[],
    percentile: number,
  ): number => {
    if (values.length === 0) return 0;

    const sorted = [...values].sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[Math.max(0, index)];
  };

  // Update metrics with new response time
  const updateMetrics = (responseTime: number, statusCode: number): void => {
    metrics.requestCount++;

    // Update response time metrics
    responseTimes.push(responseTime);

    // Keep only the last 10,000 response times to avoid memory issues
    if (responseTimes.length > 10000) {
      responseTimes.shift();
    }

    const totalTimes = responseTimes.reduce((sum, time) => sum + time, 0);
    metrics.responseTime.avg = totalTimes / responseTimes.length;
    metrics.responseTime.min = Math.min(metrics.responseTime.min, responseTime);
    metrics.responseTime.max = Math.max(metrics.responseTime.max, responseTime);

    // Calculate percentiles periodically to avoid doing it on every request
    if (metrics.requestCount % 100 === 0) {
      metrics.responseTime.p95 = calculatePercentile(responseTimes, 95);
      metrics.responseTime.p99 = calculatePercentile(responseTimes, 99);
    }

    // Track errors
    if (statusCode >= 400) {
      totalErrors++;
      errorCounts[statusCode] = (errorCounts[statusCode] || 0) + 1;
    }

    metrics.errorRate = (totalErrors / metrics.requestCount) * 100;

    // Update system metrics periodically to reduce overhead
    if (metrics.requestCount % 50 === 0) {
      const memUsage = process.memoryUsage();
      metrics.memoryUsage = {
        rss: Math.round(memUsage.rss / 1024 / 1024), // MB
        heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024), // MB
        heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024), // MB
        external: Math.round(memUsage.external / 1024 / 1024), // MB
      };
    }
  };

  // Add hooks for request/response monitoring
  fastify.addHook(
    'onRequest',
    (request: FastifyRequest, _reply: FastifyReply, done) => {
      // Store start time for this request
      request.startTime = performance.now();
      done();
    },
  );

  fastify.addHook(
    'onResponse',
    (request: FastifyRequest, reply: FastifyReply, done) => {
      const responseTime = performance.now() - (request.startTime || 0);
      updateMetrics(responseTime, reply.statusCode);
      done();
    },
  );

  // Add detailed metrics endpoint
  fastify.get(
    '/detailed',
    {
      schema: {
        response: {
          200: {
            type: 'object',
            properties: {
              metrics: { type: 'object' },
              errorCodes: { type: 'object' },
              uptime: { type: 'number' },
              timestamp: { type: 'number' },
              version: { type: 'string' },
            },
          },
        },
      },
    },
    async () => {
      return {
        metrics,
        errorCodes: errorCounts,
        uptime: process.uptime(),
        timestamp: Date.now(),
        version: process.env.npm_package_version || '1.0.0',
      };
    },
  );

  // CPU usage monitoring via sampling
  let lastCpuUsage: NodeJS.CpuUsage | null = null;
  let lastCpuTime = Date.now();

  const updateCpuUsage = (): void => {
    const currentCpuUsage = process.cpuUsage();
    const currentTime = Date.now();

    if (lastCpuUsage) {
      const userDiff = currentCpuUsage.user - lastCpuUsage.user;
      const systemDiff = currentCpuUsage.system - lastCpuUsage.system;
      const totalDiff = userDiff + systemDiff;
      const timeDiff = currentTime - lastCpuTime;

      // Convert to percentage of CPU time
      metrics.cpuUsage = (totalDiff / 1000 / timeDiff) * 100;
    }

    lastCpuUsage = currentCpuUsage;
    lastCpuTime = currentTime;
  };

  // Update CPU metrics every 5 seconds
  const cpuMonitoringInterval = setInterval(updateCpuUsage, 5000);

  // Clean up on server close
  fastify.addHook('onClose', (_instance, done) => {
    clearInterval(cpuMonitoringInterval);
    done();
  });

  // Expose metrics to the Fastify instance
  fastify.decorate('getMetrics', () => metrics);
};

export default fp(monitoringPlugin, {
  name: 'monitoring',
  fastify: '4.x',
});
