// Generated by Copilot
import { useWallet } from '@/components/wallet/WalletContext';
import { useAppStore } from '@/store/appStore';
import {
  TOKEN_PROGRAM_ID,
  createAssociatedTokenAccountInstruction,
  createTransferInstruction,
  getAssociatedTokenAddress,
} from '@solana/spl-token';
import type { ConnectionConfig } from '@solana/web3.js';
import {
  Connection,
  LAMPORTS_PER_SOL,
  ParsedTransactionWithMeta,
  PublicKey,
  SendOptions,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  clusterApiUrl,
} from '@solana/web3.js';
import { useCallback, useEffect, useMemo, useState } from 'react';

/**
 * RPC endpoints for different Solana networks
 */
export const SOLANA_ENDPOINTS = {
  mainnet: 'https://api.mainnet-beta.solana.com',
  devnet: 'https://api.devnet.solana.com',
  testnet: 'https://api.testnet.solana.com',
  localnet: 'http://localhost:8899',
};

/**
 * Default connection options with enhanced performance settings
 */
const DEFAULT_CONNECTION_OPTIONS: ConnectionConfig = {
  commitment: 'confirmed',
  disableRetryOnRateLimit: false,
  confirmTransactionInitialTimeout: 60000, // 60 seconds
};

/**
 * Create an optimized Solana connection with proper error handling
 */
export const createConnection = (endpoint = SOLANA_ENDPOINTS.mainnet) => {
  try {
    return new Connection(endpoint, DEFAULT_CONNECTION_OPTIONS);
  } catch (error) {
    console.error('Failed to create Solana connection:', error);
    throw error;
  }
};

/**
 * Hook to retrieve and manage Solana account balance with auto-refresh
 * @param address Solana account address (optional, uses connected wallet if not provided)
 * @param refreshInterval Refresh interval in milliseconds
 */
export const useSolanaBalance = (address?: string, refreshInterval = 30000) => {
  const { walletAddress, publicKey } = useWallet();
  const [balance, setBalance] = useState<number | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const targetAddress = address || walletAddress;
  const connection = createConnection();

  const fetchBalance = useCallback(async () => {
    if (!targetAddress) {
      setBalance(null);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      const pubKey = new PublicKey(targetAddress);
      const lamports = await connection.getBalance(pubKey);
      const solBalance = lamports / LAMPORTS_PER_SOL;

      setBalance(solBalance);
    } catch (err) {
      console.error('Error fetching Solana balance:', err);
      setError(
        err instanceof Error ? err : new Error('Failed to fetch balance'),
      );
    } finally {
      setIsLoading(false);
    }
  }, [connection, targetAddress]);

  useEffect(() => {
    fetchBalance();

    // Set up auto-refresh if interval is provided
    if (refreshInterval > 0 && targetAddress) {
      const intervalId = setInterval(fetchBalance, refreshInterval);
      return () => clearInterval(intervalId);
    }
  }, [fetchBalance, refreshInterval, targetAddress]);

  return { balance, isLoading, error, refetch: fetchBalance };
};

/**
 * Hook to send SOL tokens with optimized transaction parameters
 * Includes error handling, status tracking, and automatic receipt updates
 */
export const useSendSolana = () => {
  const { publicKey, sendTransaction } = useWallet();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [txHash, setTxHash] = useState<string | null>(null);
  const [status, setStatus] = useState<
    'idle' | 'pending' | 'success' | 'error'
  >('idle');
  const addToast = useAppStore((state) => state.addToast);

  const connection = createConnection();

  // Reset transaction state
  const reset = useCallback(() => {
    setIsLoading(false);
    setError(null);
    setTxHash(null);
    setStatus('idle');
  }, []);

  // Send SOL to recipient
  const sendSol = useCallback(
    async (
      recipient: string,
      amount: number,
      options?: {
        memo?: string;
        priority?: 'low' | 'medium' | 'high';
        onSuccess?: (signature: string) => void;
        onError?: (error: Error) => void;
      },
    ) => {
      if (!publicKey) {
        const error = new Error('Wallet not connected');
        setError(error);
        options?.onError?.(error);
        addToast({
          type: 'error',
          message: 'Please connect your wallet to send SOL',
        });
        return null;
      }

      try {
        setIsLoading(true);
        setStatus('pending');
        setError(null);

        // Create transaction
        const transaction = new Transaction();

        // Add transfer instruction
        const recipientPubkey = new PublicKey(recipient);
        const sendSolInstruction = SystemProgram.transfer({
          fromPubkey: publicKey,
          toPubkey: recipientPubkey,
          lamports: amount * LAMPORTS_PER_SOL,
        });

        transaction.add(sendSolInstruction);

        // Add memo if provided
        if (options?.memo) {
          const memoIx = new TransactionInstruction({
            keys: [],
            programId: new PublicKey(
              'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr',
            ),
            data: Buffer.from(options.memo),
          });
          transaction.add(memoIx);
        }

        // Set priority fee based on option
        const priorityFee =
          options?.priority === 'high'
            ? 5000
            : options?.priority === 'medium'
              ? 1000
              : 100; // default to low

        // Set recent blockhash with compute budget instruction for priority fee
        const { blockhash, lastValidBlockHeight } =
          await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = publicKey;

        // Send transaction
        const sendOptions: SendOptions = {
          skipPreflight: false,
          preflightCommitment: 'confirmed',
          maxRetries: 3,
        };

        const signature = await sendTransaction(
          transaction,
          connection,
          sendOptions,
        );
        setTxHash(signature);

        // Confirm transaction
        const confirmationPromise = connection.confirmTransaction({
          blockhash,
          lastValidBlockHeight,
          signature,
        });

        // Set timeout for transaction confirmation
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(
            () => reject(new Error('Transaction confirmation timed out')),
            60000,
          );
        });

        await Promise.race([confirmationPromise, timeoutPromise]);

        // Success
        setStatus('success');
        addToast({
          type: 'success',
          message: `Successfully sent ${amount} SOL`,
        });
        options?.onSuccess?.(signature);

        return signature;
      } catch (err) {
        console.error('Error sending SOL:', err);
        const error =
          err instanceof Error ? err : new Error('Failed to send SOL');
        setError(error);
        setStatus('error');
        options?.onError?.(error);

        addToast({
          type: 'error',
          message: `Transaction failed: ${error.message}`,
        });

        return null;
      } finally {
        setIsLoading(false);
      }
    },
    [publicKey, sendTransaction, connection, addToast],
  );

  return {
    sendSol,
    isLoading,
    error,
    txHash,
    status,
    reset,
  };
};

/**
 * Hook to query and track Solana token prices from on-chain sources
 */
export const useSolanaTokenPrice = (tokenMint: string | null) => {
  const [price, setPrice] = useState<number | null>(null);
  const [priceChange24h, setPriceChange24h] = useState<number | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  // Fetch token price from Jupiter aggregator or similar on-chain source
  const fetchTokenPrice = useCallback(async () => {
    if (!tokenMint) {
      setPrice(null);
      setPriceChange24h(null);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      // In a real implementation, this would fetch from Jupiter API or other price oracle
      // This is a mock implementation
      const response = await fetch(
        `https://price.jup.ag/v4/price?ids=${tokenMint}`,
      );
      if (!response.ok) {
        throw new Error('Failed to fetch token price');
      }

      const data = await response.json();
      if (data.data && data.data[tokenMint]) {
        setPrice(data.data[tokenMint].price);
        setPriceChange24h(data.data[tokenMint].change24h);
      }
    } catch (err) {
      console.error('Error fetching token price:', err);
      setError(
        err instanceof Error ? err : new Error('Failed to fetch token price'),
      );
    } finally {
      setIsLoading(false);
    }
  }, [tokenMint]);

  useEffect(() => {
    if (tokenMint) {
      fetchTokenPrice();

      // Auto-refresh price every 60 seconds
      const intervalId = setInterval(fetchTokenPrice, 60000);
      return () => clearInterval(intervalId);
    }
  }, [fetchTokenPrice, tokenMint]);

  return {
    price,
    priceChange24h,
    isLoading,
    error,
    refetch: fetchTokenPrice,
  };
};

/**
 * Helper to get a Solana explorer URL for addresses or transactions
 * Supports different Solana clusters
 */
export const getSolanaExplorerUrl = (
  addressOrTx: string,
  type: 'address' | 'tx' = 'address',
  cluster: 'mainnet' | 'devnet' | 'testnet' = 'mainnet',
) => {
  const baseUrl = 'https://explorer.solana.com';
  const clusterParam = cluster !== 'mainnet' ? `?cluster=${cluster}` : '';

  return `${baseUrl}/${type}/${addressOrTx}${clusterParam}`;
};

/**
 * Format Solana address for display (shortens with ellipsis)
 */
export const formatSolanaAddress = (
  address: string | null,
  length = 4,
): string => {
  if (!address) return '';

  const start = address.substring(0, length);
  const end = address.substring(address.length - length);

  return `${start}...${end}`;
};

/**
 * Format SOL amount with appropriate decimals and suffix
 */
/**
 * Formats a SOL amount with appropriate decimals and suffix.
 * - Amounts less than 0.001 are displayed in micro-SOL (`μSOL`).
 * - Amounts between 0.001 and 1 are displayed with three decimal places (`SOL`).
 * - Amounts greater than or equal to 1 are displayed with two decimal places (`SOL`).
 * @param amount The SOL amount to format (can be null).
 * @returns A formatted string representing the SOL amount.
 */
export const formatSolAmount = (amount: number | null): string => {
  if (amount === null) return '0 SOL';

  // Format based on size
  if (amount < 0.001) {
    return `${(amount * 1_000_000).toFixed(2)} μSOL`;
  } else if (amount < 1) {
    return `${amount.toFixed(3)} SOL`;
  } else {
    return `${amount.toLocaleString(undefined, {
      maximumFractionDigits: 2,
      minimumFractionDigits: 2,
    })} SOL`;
  }
};

/**
 * Interface for transaction history items
 */
export interface TransactionHistoryItem {
  signature: string;
  timestamp: number | null;
  status: 'success' | 'error';
  type: 'sent' | 'received' | 'other';
  amount: number | null;
  fee: number;
  from: string;
  to: string;
  programId: string;
  memo?: string;
}

/**
 * Hook to fetch and manage transaction history for a Solana account
 * Includes pagination, filtering, and real-time updates
 */
export const useTransactionHistory = (
  address?: string,
  limit = 10,
  refreshInterval = 30000,
) => {
  const { walletAddress } = useWallet();
  const targetAddress = address ?? walletAddress;

  const [transactions, setTransactions] = useState<TransactionHistoryItem[]>(
    [],
  );
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [hasMore, setHasMore] = useState(false);

  const connection = useMemo(
    () =>
      new Connection(clusterApiUrl('mainnet-beta'), {
        commitment: 'confirmed',
      }),
    [],
  );

  const fetchTransactions = useCallback(
    async (before?: string) => {
      if (!targetAddress) {
        setTransactions([]);
        setHasMore(false);
        setError(new Error('No wallet address available'));
        return;
      }

      try {
        setIsLoading(true);
        setError(null);

        const pubKey = new PublicKey(targetAddress);
        const options = {
          limit: limit + 1, // Fetch one extra to determine if there are more
          before,
        };

        const signatures = await connection.getSignaturesForAddress(
          pubKey,
          options,
        );
        setHasMore(signatures.length > limit);

        const validSignatures = signatures.slice(0, limit);

        const transactionPromises = validSignatures.map((sig) =>
          connection.getParsedTransaction(sig.signature, {
            maxSupportedTransactionVersion: 0,
          }),
        );

        const parsedTransactions: TransactionHistoryItem[] = (
          await Promise.all(transactionPromises)
        )
          .filter((tx): tx is ParsedTransactionWithMeta => Boolean(tx))
          .map((tx, index) => {
            const signature = validSignatures[index].signature;
            const fee = tx.meta?.fee || 0;
            const timestamp = validSignatures[index]?.blockTime || null;
            let type: 'sent' | 'received' | 'other' = 'other';
            let amount: number | null = null;
            let from = '';
            let to = '';
            let memo = '';
            const status: 'success' | 'error' = tx.meta?.err
              ? 'error'
              : 'success';

            const firstInstruction = tx.transaction.message.instructions[0];
            const programId = firstInstruction.programId?.toString() || '';

            tx.transaction.message.instructions.forEach((ix) => {
              if (
                ix.programId?.toString() ===
                'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'
              ) {
                if ('data' in ix) {
                  try {
                    memo = Buffer.from(ix.data, 'base64').toString('utf8');
                  } catch (e) {
                    console.error('Failed to parse memo data:', e);
                  }
                }
              }
            });

            if (programId === SystemProgram.programId.toString()) {
              const instruction = tx.transaction.message.instructions[0];
              if ('parsed' in instruction && instruction.parsed) {
                const { info } = instruction.parsed;
                amount = info.lamports / LAMPORTS_PER_SOL;
                from = info.source;
                to = info.destination;
                type = from === targetAddress ? 'sent' : 'received';
              }
            } else if (programId === TOKEN_PROGRAM_ID.toString()) {
              const instruction = tx.transaction.message.instructions[0];
              if ('parsed' in instruction && instruction.parsed) {
                const { info } = instruction.parsed;
                amount = Number(info.amount) / Math.pow(10, info.decimals || 0);
                from = info.authority || info.source;
                to = info.destination;
              }
            }

            return {
              signature,
              timestamp,
              status: tx.meta?.err ? 'error' : 'success',
              type,
              amount,
              fee: fee / LAMPORTS_PER_SOL,
              from,
              to,
              programId,
              memo: memo || undefined,
            };
          });

        setTransactions((prev) => {
          // Use Map to deduplicate by signature while maintaining insertion order
          const transactionMap = new Map<string, TransactionHistoryItem>();

          // Add existing transactions first to preserve chronological order
          prev.forEach((tx) => transactionMap.set(tx.signature, tx));

          // Add new transactions, overwriting duplicates with latest data
          parsedTransactions.forEach((tx) => {
            if (tx?.signature) {
              transactionMap.set(tx.signature, tx);
            }
          });

          return Array.from(transactionMap.values());
        });
      } catch (err) {
        console.error('Error fetching transaction history:', err);
        setError(
          err instanceof Error
            ? err
            : new Error('Failed to fetch transaction history'),
        );
      } finally {
        setIsLoading(false);
      }
    },
    [connection, targetAddress, limit],
  );

  const loadMore = useCallback(() => {
    fetchTransactions();
  }, [fetchTransactions]);

  useEffect(() => {
    fetchTransactions();

    if (refreshInterval > 0 && targetAddress) {
      const intervalId = setInterval(fetchTransactions, refreshInterval);
      return () => clearInterval(intervalId);
    }
  }, [fetchTransactions, refreshInterval, targetAddress]);

  return {
    transactions,
    isLoading,
    error,
    hasMore,
    loadMore,
    refetch: fetchTransactions,
  };
};

/**
 * Helper function to send SPL tokens with proper error handling and address validation
 */
export const sendSplToken = async (
  connection: Connection,
  senderWallet: {
    publicKey: PublicKey;
    signTransaction: (tx: Transaction) => Promise<Transaction>;
  },
  mint: string, // Token mint address
  recipientAddress: string,
  amount: number, // in token units (not lamports)
  decimals: number,
  options?: {
    memo?: string;
    reference?: string; // For payment tracking
    onError?: (error: Error) => void;
    onSuccess?: (signature: string) => void;
  },
): Promise<string | null> => {
  try {
    const mintPubkey = new PublicKey(mint);
    const recipientPubkey = new PublicKey(recipientAddress);

    // Get the associated token accounts
    const senderATA = await getAssociatedTokenAddress(
      mintPubkey,
      senderWallet.publicKey,
    );

    const recipientATA = await getAssociatedTokenAddress(
      mintPubkey,
      recipientPubkey,
    );

    // Check if recipient token account exists
    const recipientTokenAccount = await connection.getAccountInfo(recipientATA);

    // Create transaction
    const transaction = new Transaction();

    // If recipient token account doesn't exist, create it
    if (!recipientTokenAccount) {
      transaction.add(
        createAssociatedTokenAccountInstruction(
          senderWallet.publicKey, // payer
          recipientATA, // associated token account
          recipientPubkey, // owner
          mintPubkey, // mint
        ),
      );
    }

    // Add token transfer instruction
    // Convert token amount to smallest units based on decimals
    const tokenAmount = Math.floor(amount * Math.pow(10, decimals));

    transaction.add(
      createTransferInstruction(
        senderATA, // source
        recipientATA, // destination
        senderWallet.publicKey, // owner
        tokenAmount, // amount in smallest units
      ),
    );

    // Add memo if provided
    if (options?.memo) {
      const memoIx = new TransactionInstruction({
        keys: [],
        programId: new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),
        data: Buffer.from(options.memo),
      });
      transaction.add(memoIx);
    }

    // Get recent blockhash for transaction
    const { blockhash, lastValidBlockHeight } =
      await connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = senderWallet.publicKey;

    // Sign transaction
    const signedTx = await senderWallet.signTransaction(transaction);

    // Send transaction
    const signature = await connection.sendRawTransaction(
      signedTx.serialize(),
      {
        skipPreflight: false,
        preflightCommitment: 'confirmed',
        maxRetries: 3,
      },
    );

    // Confirm transaction
    const confirmation = await connection.confirmTransaction({
      blockhash,
      lastValidBlockHeight,
      signature,
    });

    if (confirmation.value.err) {
      throw new Error(
        `Transaction confirmed but failed: ${confirmation.value.err.toString()}`,
      );
    }

    options?.onSuccess?.(signature);
    return signature;
  } catch (err) {
    console.error('Error sending SPL token:', err);
    const error =
      err instanceof Error ? err : new Error('Failed to send SPL token');
    options?.onError?.(error);
    return null;
  }
};

/**
 * Utility function to get token account balances for a given wallet
 * Returns a map of mint addresses to token amounts
 */
export const getTokenBalances = async (
  connection: Connection,
  walletAddress: string,
): Promise<Map<string, { amount: number; decimals: number }>> => {
  try {
    const pubkey = new PublicKey(walletAddress);

    // Get all token accounts owned by this wallet
    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
      pubkey,
      { programId: TOKEN_PROGRAM_ID },
    );

    // Create a map of mint address to token amount
    const balances = new Map<string, { amount: number; decimals: number }>();

    for (const { account } of tokenAccounts.value) {
      const parsedAccountInfo = account.data.parsed;
      const info = parsedAccountInfo.info;

      if (
        info.tokenAmount &&
        info.tokenAmount.amount !== '0' // Filter out empty accounts
      ) {
        const mintAddress = info.mint;
        const decimals = info.tokenAmount.decimals;
        const amount = Number(info.tokenAmount.amount) / Math.pow(10, decimals);

        balances.set(mintAddress, { amount, decimals });
      }
    }

    return balances;
  } catch (err) {
    console.error('Error fetching token balances:', err);
    throw err instanceof Error
      ? err
      : new Error('Failed to fetch token balances');
  }
};
