import {filterDuplicates, runSingleTestCase, TestSuite} from '../../_main';

export type Input<T = any> = {
	array: T[];
	mapper?: (item: T) => any;
};

export type Result = any[];
export type TestSuite_filterDuplicates = TestSuite<Input, Result>;
export type TestCase_filterDuplicates = TestSuite_filterDuplicates['testcases'][number];

const test = async (input: Input): Promise<Result> => {
	return filterDuplicates(input.array, input.mapper);
};

const runTestCase = (testCase: TestCase_filterDuplicates) => {
	return () => runSingleTestCase(test, testCase);
};

describe('filterDuplicates', () => {
	it('Returns unique numbers without duplicates', runTestCase({
		input: {
			array: [1, 2, 3],
			mapper: undefined
		},
		result: [1, 2, 3]
	}));

	it('Removes trailing duplicate number', runTestCase({
		input: {
			array: [1, 2, 3, 3],
			mapper: undefined
		},
		result: [1, 2, 3]
	}));

	it('Removes duplicate strings', runTestCase({
		input: {
			array: [1, 2, 'abc', 'abc'],
			mapper: undefined
		},
		result: [1, 2, 'abc']
	}));

	it('Keeps distinct objects due to reference inequality', runTestCase({
		input: {
			array: [1, 2, {}, {}],
			mapper: undefined
		},
		result: [1, 2, {}, {}]
	}));

	it('Filters based on .a value using mapper', runTestCase({
		input: {
			array: [{a: 2}, {a: 2, b: 2}, {a: {b: 3}}, {a: 3, b: 2}],
			mapper: item => item.a
		},
		result: [{a: 2}, {a: {b: 3}}, {a: 3, b: 2}]
	}));

	// Generated by ChatGPT - 2025-05-25T23:00
	it('GPT - Handles deeply nested objects with same reference', runTestCase({
		input: {
			array: [{a: {x: 1}}, {a: {x: 1}}, {a: {x: 2}}],
			mapper: item => JSON.stringify(item)
		},
		result: [{a: {x: 1}}, {a: {x: 2}}]
	}));

	// Generated by ChatGPT - 2025-05-25T23:00
	it('GPT - Filters duplicates using boolean mapper', runTestCase({
		input: {
			array: [true, false, true, false],
			mapper: x => x
		},
		result: [true, false]
	}));
});
