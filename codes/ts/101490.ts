// Generated by Copilot
import { Type } from '@sinclair/typebox';
import { FastifyInstance } from 'fastify';

/**
 * Integration with existing NestJS leaderboard service
 * @param fastify - Fastify instance
 */
export async function leaderboardRoutes(
  fastify: FastifyInstance,
): Promise<void> {
  // Get leaderboard endpoint
  fastify.get(
    '/',
    {
      schema: {
        querystring: Type.Object({
          limit: Type.Optional(
            Type.Number({ minimum: 1, maximum: 100, default: 10 }),
          ),
          offset: Type.Optional(Type.Number({ minimum: 0, default: 0 })),
          timeframe: Type.Optional(
            Type.String({ enum: ['day', 'week', 'month', 'all'] }),
          ),
        }),
        response: {
          200: Type.Object({
            data: Type.Array(
              Type.Object({
                id: Type.String(),
                username: Type.String(),
                score: Type.Number(),
                rank: Type.Number(),
                avatar: Type.Optional(Type.String()),
                level: Type.Number(),
                isCurrentUser: Type.Optional(Type.Boolean()),
              }),
            ),
            meta: Type.Object({
              total: Type.Number(),
              limit: Type.Number(),
              offset: Type.Number(),
              timeframe: Type.String(),
            }),
          }),
        },
      },
    },
    async (request) => {
      try {
        const {
          limit = 10,
          offset = 0,
          timeframe = 'all',
        } = request.query as any;

        // This is where we'll integrate with the existing NestJS leaderboard service
        // For now, we'll use mock data but in production this would call the actual service

        // Import the actual service in production
        // const leaderboardService = await import('../../leaderboard/leaderboard.service');
        // return await leaderboardService.getLeaderboard({ limit, offset, timeframe });

        // Mock data for demonstration
        const leaderboardData = Array.from({ length: limit }).map((_, i) => ({
          id: `user-${i + offset + 1}`,
          username: `User ${i + offset + 1}`,
          score: Math.floor(10000 / (i + offset + 1)),
          rank: i + offset + 1,
          avatar: `https://avatars.wikiflow.com/user-${i + offset + 1}.png`,
          level: Math.floor(Math.random() * 100) + 1,
          isCurrentUser: i + offset === 2,
        }));

        return {
          data: leaderboardData,
          meta: {
            total: 1000,
            limit,
            offset,
            timeframe,
          },
        };
      } catch (error) {
        fastify.log.error(error);
        throw new Error('Failed to fetch leaderboard data');
      }
    },
  );

  // Get user ranking endpoint
  fastify.get(
    '/ranking/:userId',
    {
      schema: {
        params: Type.Object({
          userId: Type.String(),
        }),
        response: {
          200: Type.Object({
            rank: Type.Number(),
            score: Type.Number(),
            username: Type.String(),
            percentile: Type.Number(),
          }),
          404: Type.Object({
            message: Type.String(),
          }),
        },
      },
    },
    async (request, reply) => {
      const { userId } = request.params as { userId: string };

      try {
        // This would call the actual service in production
        // const leaderboardService = await import('../../leaderboard/leaderboard.service');
        // const userRanking = await leaderboardService.getUserRanking(userId);

        // Mock data for demonstration
        if (userId === 'not-found') {
          return reply
            .code(404)
            .send({ message: 'User not found in leaderboard' });
        }

        return {
          rank: 42,
          score: 7500,
          username: 'WikiFlow Champion',
          percentile: 0.95,
        };
      } catch (error) {
        fastify.log.error(error);
        throw new Error('Failed to fetch user ranking');
      }
    },
  );
}
