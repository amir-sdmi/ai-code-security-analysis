// create-decsion/index.ts

import {serve} from "std/server";
import {createClient} from "@supabase/supabase-js";

serve(async (req: Request) => {
  try {
    // Extract JWT token from the Authorization header
    const authHeader = req.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return new Response(
        JSON.stringify({ error: "Missing or invalid Authorization header" }),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }
    const token = authHeader.split("Bearer ")[1];

    // Initialize the Supabase client with your service role key
    const supabaseUrl = Deno.env.get("SUPABASE_URL") || "";
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || "";
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Verify the token and get the user using Supabase's built-in auth feature.
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Unauthorized user" }),
        { status: 401, headers: { "Content-Type": "application/json" } }
      );
    }

    // Parse request body for pendingDecisionId
    const { pendingDecisionId } = await req.json();
    if (!pendingDecisionId) {
      return new Response(
        JSON.stringify({ error: "pendingDecisionId is required" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    // Fetch pending decision from the database
    const { data: pendingDecision, error: fetchError } = await supabase
      .from("pending_decisions")
      .select("id, user_id, original_query, image_path, created_at")
      .eq("id", pendingDecisionId)
      .eq("user_id", user.id)
      .single();

    if (fetchError || !pendingDecision) {
      return new Response(
        JSON.stringify({ error: "Pending decision not found" }),
        { status: 404, headers: { "Content-Type": "application/json" } }
      );
    }

    const { original_query, image_path, created_at } = pendingDecision;
    // Build your prompt. You can incorporate image_path or other data as needed.
    const prompt = original_query;

    // Call Gemini API
    const geminiApiKey = Deno.env.get("GEMINI_API_KEY") || "";
    const geminiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-pro-exp-02-05:generateContent?key=${geminiApiKey}`;

    const geminiPayload = {
      contents: [
        {
          role: "user",
          parts: [
            {
              text: prompt,
            },
          ],
        },
      ],
      generationConfig: {
        temperature: 1,
        topK: 64,
        topP: 0.95,
        maxOutputTokens: 8192,
        responseMimeType: "text/plain",
      },
    };

    const geminiResponse = await fetch(geminiEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(geminiPayload),
    });

    if (!geminiResponse.ok) {
      return new Response(
        JSON.stringify({ error: "Error calling Gemini API" }),
        { status: geminiResponse.status, headers: { "Content-Type": "application/json" } }
      );
    }

    const geminiResult = await geminiResponse.json();
    // The Gemini API returns a "candidates" array.
    if (!geminiResult.candidates || geminiResult.candidates.length === 0) {
      return new Response(
        JSON.stringify({ error: "No content generated by Gemini API" }),
        { status: 500, headers: { "Content-Type": "application/json" } }
      );
    }
    // output is a JSON string containing 'question' and 'options'.
    let parsedOutput;
    try {
      parsedOutput = JSON.parse(geminiResult.candidates[0].output);
    } catch (e) {
      return new Response(
        JSON.stringify({ error: "Failed to parse Gemini API output" }),
        { status: 500, headers: { "Content-Type": "application/json" } }
      );
    }
    const { question, options } = parsedOutput;
    if (!question || !options || !Array.isArray(options)) {
      return new Response(
        JSON.stringify({ error: "Invalid output format from Gemini API" }),
        { status: 500, headers: { "Content-Type": "application/json" } }
      );
    }

    // Select a random option from the options array.
    const choice = options[Math.floor(Math.random() * options.length)];

    // Insert the decision into the decisions table.
    const { data: decisionData, error: insertError } = await supabase
      .from("decisions")
      .insert({
        created_at,
        user_id: user.id,
        options,
        choice,
      })
      .select("id")
      .maybeSingle();

    if (insertError || !decisionData) {
      return new Response(
        JSON.stringify({ error: "Error saving decision" }),
        { status: 500, headers: { "Content-Type": "application/json" } }
      );
    }

    return new Response(
      JSON.stringify({ id: decisionData.id }),
      { status: 200, headers: { "Content-Type": "application/json" } }
    );
  } catch (error: any) {
    return new Response(
      JSON.stringify({ error: error.message || "Unexpected error" }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
});
