import { StoryConfig } from '../types/story';

export class GeminiService {
  private apiKey: string;

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async generateStoryPages(config: StoryConfig): Promise<string[]> {
    const prompt = this.buildStoryPrompt(config);
    
    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          },
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;
        throw new Error(`Gemini API error: ${errorMessage}`);
      }

      const data = await response.json();
      
      if (data.candidates?.[0]?.finishReason === 'SAFETY') {
        throw new Error('Content was blocked by safety filters. Please try a different story concept.');
      }
      
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No content generated by Gemini API');
      }

      return this.parseStoryPages(generatedText, config.pageCount);
    } catch (error) {
      console.error('Gemini API error:', error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Unknown error occurred while generating story');
    }
  }

  async regeneratePageText(originalText: string, context: string): Promise<string> {
    const prompt = `Rewrite this children's story page text with variation while keeping the same meaning and story flow:

Original text: "${originalText}"

Story context: ${context}

Requirements:
- Keep it age-appropriate and engaging
- Maintain the same story progression
- Use similar word count (${originalText.split(' ').length} words approximately)
- Make it flow naturally with the story
- Ensure it's suitable for children

New version:`;

    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.8,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 500,
          },
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;
        throw new Error(`Gemini API error: ${errorMessage}`);
      }

      const data = await response.json();
      
      if (data.candidates?.[0]?.finishReason === 'SAFETY') {
        throw new Error('Content was blocked by safety filters. Please try different text.');
      }
      
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No content generated by Gemini API');
      }

      return generatedText.trim();
    } catch (error) {
      console.error('Gemini API error:', error);
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Unknown error occurred while regenerating text');
    }
  }

  private buildStoryPrompt(config: StoryConfig): string {
    let prompt = '';

    // Use template prompt if available
    if (config.template) {
      prompt = config.template.promptTemplate.replace('{character}', config.character.name);
    } else {
      prompt = `Create a children's story with the following specifications:

Title: ${config.title}
Age Group: ${config.ageGroup}
Genre: ${config.genre}
Theme: ${config.theme}
Main Character: ${config.character.name} - ${config.character.description}
Character Traits: ${config.character.traits.join(', ')}
Pages: ${config.pageCount}`;
    }

    // Add character appearance details
    if (config.character.appearance) {
      const appearance = config.character.appearance;
      const appearanceDetails = [];
      
      if (appearance.species) appearanceDetails.push(`Species: ${appearance.species}`);
      if (appearance.hairColor) appearanceDetails.push(`Hair: ${appearance.hairColor}`);
      if (appearance.eyeColor) appearanceDetails.push(`Eyes: ${appearance.eyeColor}`);
      if (appearance.clothing) appearanceDetails.push(`Clothing: ${appearance.clothing}`);
      if (appearance.accessories && appearance.accessories.length > 0) {
        appearanceDetails.push(`Accessories: ${appearance.accessories.join(', ')}`);
      }
      
      if (appearanceDetails.length > 0) {
        prompt += `\nCharacter Appearance: ${appearanceDetails.join(', ')}`;
      }
    }

    // Add relationships
    if (config.character.relationships && config.character.relationships.length > 0) {
      const relationships = config.character.relationships
        .map(rel => `${rel.name} (${rel.relationship}): ${rel.description}`)
        .join(', ');
      prompt += `\nCharacter Relationships: ${relationships}`;
    }

    // Add additional characters
    if (config.additionalCharacters && config.additionalCharacters.length > 0) {
      const additionalChars = config.additionalCharacters
        .filter(char => char.name && char.description)
        .map(char => `${char.name}: ${char.description} (${char.traits.join(', ')})`)
        .join(', ');
      
      if (additionalChars) {
        prompt += `\nAdditional Characters: ${additionalChars}`;
      }
    }

    // Add custom prompt
    if (config.customPrompt) {
      prompt += `\nAdditional Requirements: ${config.customPrompt}`;
    }

    prompt += `

Please write a complete story divided into exactly ${config.pageCount} pages. Each page should have 2-4 sentences that are age-appropriate for ${config.ageGroup}. The story should be engaging, educational, and have a positive message about ${config.theme}.

IMPORTANT: Format the output exactly as follows:
Page 1: [text for page 1]
Page 2: [text for page 2]
Page 3: [text for page 3]
...and so on for all ${config.pageCount} pages.

Make sure:
- Each page has enough content to stand alone with an illustration
- The story flows naturally from page to page
- The content is appropriate for the target age group
- The story has a clear beginning, middle, and end
- The character ${config.character.name} is featured prominently
- Include any additional characters naturally in the story`;

    return prompt;
  }

  private parseStoryPages(generatedText: string, expectedPages: number): string[] {
    const pages: string[] = [];
    const lines = generatedText.split('\n').filter(line => line.trim());
    
    // Try to parse "Page X:" format first
    for (const line of lines) {
      const pageMatch = line.match(/^Page\s+(\d+):\s*(.+)/i);
      if (pageMatch && pageMatch[2]) {
        pages.push(pageMatch[2].trim());
      }
    }

    // If we got the expected number of pages, return them
    if (pages.length === expectedPages) {
      return pages;
    }

    // If parsing failed or we got wrong number of pages, try alternative parsing
    if (pages.length === 0) {
      // Try to split by numbered patterns
      const numberedSections = generatedText.split(/(?=\d+\.|\d+\)|\(\d+\))/);
      for (const section of numberedSections) {
        const cleanText = section.replace(/^\d+[.)]\s*/, '').trim();
        if (cleanText && cleanText.length > 10) {
          pages.push(cleanText);
        }
      }
    }

    // Last resort: split into sentences and group them
    if (pages.length === 0 || pages.length !== expectedPages) {
      const sentences = generatedText
        .split(/[.!?]+/)
        .map(s => s.trim())
        .filter(s => s.length > 10);
      
      const sentencesPerPage = Math.max(1, Math.ceil(sentences.length / expectedPages));
      const newPages: string[] = [];
      
      for (let i = 0; i < expectedPages; i++) {
        const start = i * sentencesPerPage;
        const end = Math.min(start + sentencesPerPage, sentences.length);
        const pageText = sentences.slice(start, end).join('. ').trim();
        
        if (pageText) {
          newPages.push(pageText + (pageText.endsWith('.') ? '' : '.'));
        } else {
          // Generate a simple page if we run out of content
          newPages.push(`The story continues with the characters on their adventure.`);
        }
      }
      
      return newPages;
    }

    // Ensure we have exactly the expected number of pages
    if (pages.length > expectedPages) {
      return pages.slice(0, expectedPages);
    } else if (pages.length < expectedPages) {
      // Pad with simple continuation pages
      while (pages.length < expectedPages) {
        pages.push(`The adventure continues...`);
      }
    }

    return pages;
  }
}