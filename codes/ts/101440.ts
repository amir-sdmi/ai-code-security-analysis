// Generated by Copilot
import { Controller, Get, Post, Body, Param, Delete, Query, BadRequestException, Logger } from '@nestjs/common';
import { LeaderboardService } from './leaderboard.service';
import { LeaderboardEntry, NewLeaderboardEntry } from '../../../drizzle/schema';

/**
 * Controller for GPU benchmark leaderboard API endpoints
 */
@Controller('leaderboard')
export class LeaderboardController {
  private readonly logger = new Logger(LeaderboardController.name);

  constructor(private readonly leaderboardService: LeaderboardService) {}

  /**
   * Get all leaderboard entries
   * @param limit Optional limit parameter
   * @returns Array of leaderboard entries
   */
  @Get()
  async getLeaderboard(@Query('limit') limit?: string): Promise<LeaderboardEntry[]> {
    try {
      const limitNum = limit ? parseInt(limit, 10) : 50;
      if (isNaN(limitNum) || limitNum < 1) {
        throw new BadRequestException('Limit must be a positive number');
      }
      return await this.leaderboardService.getAll(limitNum);
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      this.logger.error(`Failed to get leaderboard: ${error.message}`, error.stack);
      throw new BadRequestException('Could not retrieve leaderboard data');
    }
  }

  /**
   * Add a new entry to the leaderboard
   * @param entry The leaderboard entry data
   * @returns The created entry
   */
  @Post()
  async addEntry(@Body() entry: NewLeaderboardEntry): Promise<LeaderboardEntry> {
    try {
      // Basic validation
      if (!entry.username || !entry.gpuInfo || !entry.score) {
        throw new BadRequestException('Username, GPU info, and score are required');
      }
      
      // Ensure score is a positive number
      if (entry.score < 0) {
        throw new BadRequestException('Score must be a positive number');
      }
      
      return await this.leaderboardService.addEntry(entry);
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      this.logger.error(`Failed to add leaderboard entry: ${error.message}`, error.stack);
      throw new BadRequestException('Could not add leaderboard entry');
    }
  }

  /**
   * Get leaderboard entries for a specific wallet address
   * @param walletAddress The wallet address to look up
   * @returns Array of matching leaderboard entries
   */
  @Get('wallet/:address')
  async getByWallet(@Param('address') walletAddress: string): Promise<LeaderboardEntry[]> {
    try {
      if (!walletAddress) {
        throw new BadRequestException('Wallet address is required');
      }
      return await this.leaderboardService.getByWallet(walletAddress);
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      this.logger.error(`Failed to get entries by wallet: ${error.message}`, error.stack);
      throw new BadRequestException('Could not retrieve leaderboard data for this wallet');
    }
  }

  /**
   * Get a user's rank in the leaderboard
   * @param walletAddress The wallet address to get rank for
   * @returns Rank information
   */
  @Get('rank/:address')
  async getUserRank(@Param('address') walletAddress: string): Promise<{ rank: number; total: number; topScore: number | null }> {
    try {
      if (!walletAddress) {
        throw new BadRequestException('Wallet address is required');
      }
      return await this.leaderboardService.getUserRank(walletAddress);
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      this.logger.error(`Failed to get user rank: ${error.message}`, error.stack);
      throw new BadRequestException('Could not retrieve rank information');
    }
  }

  /**
   * Delete a leaderboard entry
   * @param id The ID of the entry to delete
   * @returns Success message
   */
  @Delete(':id')
  async deleteEntry(@Param('id') id: string): Promise<{ success: boolean }> {
    try {
      const idNum = parseInt(id, 10);
      if (isNaN(idNum)) {
        throw new BadRequestException('ID must be a number');
      }
      
      const success = await this.leaderboardService.deleteEntry(idNum);
      return { success };
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      this.logger.error(`Failed to delete leaderboard entry: ${error.message}`, error.stack);
      throw new BadRequestException('Could not delete leaderboard entry');
    }
  }
}