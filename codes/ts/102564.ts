import { GEMINI_CONFIG } from '../config/apiKeys';
import ENV from '../lib/env'; // Import the ENV object
import { mockGenerateText, mockGenerateChatCompletion, mockStreamChatCompletion } from './mockGeminiService';
import { Recipe, Ingredient, Step, NutritionalInfo } from '../services/recipeService';
import { v4 as uuidv4 } from 'uuid';
import { 
  ChatMessage, 
  createUserMessage, 
  createModelMessage, 
  GeminiRequest, 
  GeminiResponse, 
  GeminiRequestPayload 
} from './geminiTypes';

// Gemini API endpoints from config
const { BASE_URL, MODEL, API_KEY } = GEMINI_CONFIG;

// Define environment variable for API key
// Use the ENV object which properly handles all the fallbacks
const GEMINI_API_KEY = ENV.GEMINI_API_KEY || API_KEY || 'your-api-key-here';

// Gemini API endpoint
const GEMINI_API_URL = BASE_URL ? `${BASE_URL}/models/${MODEL}:generateContent` :
  'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';

// Re-export types and helpers for backward compatibility
export type { ChatMessage, GeminiRequest, GeminiResponse, GeminiRequestPayload };
export { createUserMessage, createModelMessage };

/**
 * Generate text using Gemini API
 * @param prompt - The prompt to generate text from
 * @returns The generated text
 */
export const generateText = async (prompt: string): Promise<string> => {
  if (ENV.USE_MOCK_GEMINI) { // Adjust ENV.USE_MOCK_GEMINI based on your env setup
    return mockGenerateText(prompt);
  }
  try {
    // Validate API key
    if (!GEMINI_API_KEY || GEMINI_API_KEY === 'your-api-key-here') {
      throw new Error('Gemini API key is not configured');
    }

    if (__DEV__) {
      console.log('Sending prompt to Gemini API:', prompt.substring(0, 100) + '...');
    }

    // Prepare request
    const request: GeminiRequest = {
      contents: [
        {
          parts: [
            {
              text: prompt,
            },
          ],
        },
      ],
    };

    // Make API call
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    // Check for errors
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API error status:', response.status, response.statusText);
      console.error('Error response body:', errorText);
      
      let errorData;
      try {
        errorData = JSON.parse(errorText);
      } catch (e) {
        errorData = { error: { message: 'Failed to parse error response' } };
      }
      
      throw new Error(`Gemini API error: ${errorData.error?.message || response.statusText}`);
    }

    // Parse response
    const responseText = await response.text();
    if (__DEV__) {
      console.log('Received response from Gemini:', responseText.substring(0, 100) + '...');
    }
    
    let data;
    try {
      data = JSON.parse(responseText) as GeminiResponse;
    } catch (e) {
      console.error('Error parsing Gemini response:', e);
      console.error('Raw response:', responseText);
      throw new Error('Invalid JSON response from Gemini API');
    }
    
    // Extract generated text
    if (data.candidates && data.candidates.length > 0) {
      const generatedText = data.candidates[0].content.parts[0].text;
      return generatedText;
    } else {
      console.error('No candidates in response:', data);
      throw new Error('No text generated by Gemini');
    }
  } catch (error) {
    console.error('Error in generateText:', error);
    throw error;
  }
};

/**
 * Generate chat completion using Gemini API
 * @param messages - Array of chat messages
 * @returns The generated response
 */
export const generateChatCompletion = async (messages: ChatMessage[]): Promise<string> => {
  if (ENV.USE_MOCK_GEMINI) { // Adjust ENV.USE_MOCK_GEMINI based on your env setup
    return mockGenerateChatCompletion(messages);
  }
  try {
    const url = `${BASE_URL}/models/${MODEL}:generateContent?key=${API_KEY}`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: messages,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Gemini API error: ${errorData.error?.message || response.statusText}`);
    }

    const data = await response.json();
    
    if (data && data.candidates && data.candidates.length > 0) {
      const candidate = data.candidates[0];
      if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
        return candidate.content.parts[0].text;
      }
    }
    
    return 'Sorry, I could not generate a response.';
  } catch (error: unknown) {
    console.error('Error generating chat completion with Gemini API:', error);
    throw new Error('Failed to generate chat completion with Gemini API');
  }
};

/**
 * Generate chat stream using Gemini API (for streaming responses)
 * This is a placeholder as the REST API doesn't directly support streaming.
 * For actual streaming implementation, you would need to use server-side implementation
 * or implement a chunking mechanism on the client side.
 * Note: We use fetch API instead of axios for better React Native compatibility.
 */
export const streamChatCompletion = async (
  messages: ChatMessage[],
  onChunk: (chunk: string) => void
): Promise<void> => {
  if (ENV.USE_MOCK_GEMINI) { // Adjust ENV.USE_MOCK_GEMINI based on your env setup
    return mockStreamChatCompletion(messages, onChunk);
  }
  try {
    // For now, we'll simulate streaming by breaking the response into chunks
    const fullResponse = await generateChatCompletion(messages);
    
    // Split the response into "chunks" to simulate streaming
    const chunks = fullResponse.match(/.{1,20}/g) || [];
    
    // Send chunks with a small delay
    for (const chunk of chunks) {
      onChunk(chunk);
      await new Promise(resolve => setTimeout(resolve, 50));
    }
  } catch (error: unknown) {
    console.error('Error streaming chat completion:', error);
    throw new Error('Failed to stream chat completion');
  }
};

// Define the interface for recipe generation parameters
export interface RecipeGenerationParams {
  ingredients?: string[];
  mealType?: string;
  cuisine?: string;
  dietaryRestrictions?: string[];
  cookingTime?: number;
  difficulty?: string;
  servings?: number;
  userPreferences?: any;
  customPrompt?: string;
  systemPromptAddition?: string;
  timeLimit?: string;
  applyPreferences?: boolean;
  recipeTitle?: string;
  seasonalContext?: {
    season: string;
    dish: any;
  };
}

/**
 * Generates a recipe using the Gemini API
 */
export const generateRecipeWithGemini = async (params: RecipeGenerationParams): Promise<Recipe> => {
  if (ENV.USE_MOCK_GEMINI) {
    return generateMockRecipe(params);
  }
  
  try {
    if (__DEV__) {
    console.log('Generating recipe with Gemini using params:', JSON.stringify(params));
  }
    
    // Create prompt for Gemini API
    const prompt = createRecipePrompt(params);
    
    // Call Gemini API
    const response = await generateText(prompt);
    
    // Parse response into Recipe object
    const recipe = parseGeminiResponse({ candidates: [{ content: { parts: [{ text: response }] } }] });
    
    // Ensure cuisine is properly set
    if (params.cuisine && params.cuisine !== 'any') {
      recipe.cuisineType = params.cuisine;
      
      // Add cuisine to tags if not already present
      if (!recipe.tags) {
        recipe.tags = [params.cuisine.toLowerCase()];
      } else if (!recipe.tags.includes(params.cuisine.toLowerCase())) {
        recipe.tags.push(params.cuisine.toLowerCase());
      }
    }
    
    return recipe;
  } catch (error) {
    console.error('Error generating recipe with Gemini:', error);
    return generateMockRecipe(params);
  }
};

/**
 * Create a prompt for the Gemini API to generate a recipe
 */
const createRecipePrompt = (params: RecipeGenerationParams): string => {
  const {
    ingredients = [],
    mealType = 'any',
    cuisine = 'any',
    dietaryRestrictions = [],
    cookingTime,
    difficulty,
    servings,
    userPreferences,
    customPrompt,
    systemPromptAddition,
    timeLimit,
    applyPreferences,
    recipeTitle,
    seasonalContext
  } = params;
  
  // Handle seasonal recipe generation
  if (seasonalContext && recipeTitle) {
    const { season, dish } = seasonalContext;
    const dishIngredients = dish?.ingredients || [];
    
    let prompt = `Generate a detailed recipe for "${recipeTitle}" that focuses on seasonal ${season} ingredients and flavors.`;
    
    if (dishIngredients.length > 0) {
      prompt += `\nKey seasonal ingredients to feature: ${dishIngredients.join(', ')}`;
    }
    
    const seasonName = season && typeof season === 'string' ? season.charAt(0).toUpperCase() + season.slice(1) : 'Current';
    prompt += `\nSeason: ${seasonName}`;
    prompt += `\nThis recipe should celebrate the best of ${season || 'seasonal'} season with fresh, seasonal ingredients and appropriate ${season || 'seasonal'} cooking techniques.`;
    
    // Add other parameters as normal
    if (servings && servings > 0) {
      prompt += `\nServings: ${servings}`;
    }
    
    if (timeLimit && timeLimit !== 'no-limit') {
      const timeLimitMinutes = timeLimit === '15' ? 15 : timeLimit === '30' ? 30 : timeLimit === '60' ? 60 : null;
      if (timeLimitMinutes) {
        prompt += `\nTime Constraint: Recipe must be completable in under ${timeLimitMinutes} minutes total.`;
      }
    }
    
    // Add user preferences for seasonal recipes
    if (userPreferences && applyPreferences !== false) {
      if (userPreferences.allergies && userPreferences.allergies.length > 0) {
        prompt += `\nAllergies (IMPORTANT - MUST EXCLUDE THESE): ${userPreferences.allergies.join(', ')}`;
      }
      
      if (userPreferences.spice_level) {
        prompt += `\nSpice Level: ${userPreferences.spice_level}`;
      }
    }
    
    // Add format instructions
    prompt += `\n\nPlease format the recipe in the following JSON structure:
    {
      "title": "${recipeTitle}",
      "description": "A brief description highlighting the seasonal nature of this ${season} recipe",
      "cuisineName": "Seasonal ${seasonName}",
      "cookTimeMinutes": cooking time in minutes (number),
      "prepTimeMinutes": prep time in minutes (number),
      "difficulty": "Easy|Medium|Hard",
      "servings": ${servings || 4},
      "ingredients": [
        {
          "name": "ingredient name",
          "quantity": "amount",
          "unit": "measurement unit"
        }
      ],
      "steps": [
        {
          "description": "Step description",
          "time": optional time in minutes (number)
        }
      ],
      "nutritionalInfo": {
        "calories": calories per serving (number),
        "protein": protein in grams (number),
        "carbs": carbs in grams (number),
        "fat": fat in grams (number)
      },
      "cookingTips": [
        "Seasonal cooking tip 1",
        "Seasonal cooking tip 2"
      ],
      "tags": ["seasonal", "${season}", "fresh", "other relevant tags"]
    }`;
    
    return prompt;
  }
  
  // Build the base prompt with system instructions for non-seasonal recipes
  let prompt = `Generate a detailed recipe with the following requirements:`;
  
  // Add system prompt addition if provided
  if (systemPromptAddition) {
    prompt = `${systemPromptAddition}\n\n${prompt}`;
  }
  
  // If a specific recipe title is provided, focus on that
  if (recipeTitle && !seasonalContext) {
    prompt = `Generate a detailed recipe for "${recipeTitle}".`;
    
    if (cuisine && cuisine !== 'any' && cuisine !== 'ingredient-based') {
      prompt += `\nThis should be an authentic ${cuisine} version of "${recipeTitle}" following traditional ${cuisine} cooking methods and flavors.`;
    }
    
    prompt += `\nMake this recipe true to the name "${recipeTitle}" - use traditional ingredients and cooking methods that are appropriate for this specific dish.`;
  } else {
    // Build the base prompt with system instructions for non-seasonal recipes
    prompt = `Generate a detailed recipe with the following requirements:`;
    
    // Add system prompt addition if provided
    if (systemPromptAddition) {
      prompt = `${systemPromptAddition}\n\n${prompt}`;
    }
  }
  
  // Add ingredients if provided (for ingredient-based recipes)
  if (ingredients.length > 0 && !recipeTitle) {
    prompt += `\nIngredients: ${ingredients.join(', ')}`;
  }
  
  // Add cuisine with emphasis if provided (but not if we already have a specific recipe title)
  if (cuisine !== 'any' && cuisine !== 'ingredient-based' && !recipeTitle) {
    prompt += `\nCuisine: ${cuisine} (IMPORTANT: This recipe MUST be authentic ${cuisine} cuisine and follow ${cuisine} cooking traditions and flavors)`;
  } else if (cuisine === 'ingredient-based' && !recipeTitle) {
    prompt += `\nCooking Style: Let the ingredients naturally determine the cooking style and flavors. Create a recipe that best showcases these ingredients without forcing any specific cuisine. The recipe should be practical and delicious, using techniques that complement the ingredients.`;
  }
  
  // Add meal type if provided (but not if we have a specific recipe title)
  if (mealType !== 'any' && mealType !== 'ingredient-based' && !recipeTitle) {
    prompt += `\nMeal Type: ${mealType}`;
  } else if (mealType === 'ingredient-based' && !recipeTitle) {
    prompt += `\nMeal Planning: Create a recipe that makes the best use of the provided ingredients, choosing appropriate meal type (breakfast, lunch, dinner, or snack) based on what works best with these ingredients.`;
  }
  
  // Add dietary restrictions if provided
  if (dietaryRestrictions.length > 0) {
    prompt += `\nDietary Restrictions: ${dietaryRestrictions.join(', ')}`;
  }
  
  // Add user preferences if provided and applyPreferences is true
  if (userPreferences && applyPreferences !== false) {
    if (userPreferences.dietary_profile && userPreferences.dietary_profile.length > 0) {
      prompt += `\nDietary Profile: ${userPreferences.dietary_profile.join(', ')}`;
    }
    
    if (userPreferences.allergies && userPreferences.allergies.length > 0) {
      prompt += `\nAllergies (IMPORTANT - MUST EXCLUDE THESE): ${userPreferences.allergies.join(', ')}`;
    }
    
    if (userPreferences.disliked_ingredients && userPreferences.disliked_ingredients.length > 0) {
      prompt += `\nDisliked Ingredients (Avoid if possible): ${userPreferences.disliked_ingredients.join(', ')}`;
    }
    
    if (userPreferences.spice_level) {
      prompt += `\nSpice Level: ${userPreferences.spice_level}`;
    }
  }
  
  // Add cooking time if provided
  if (cookingTime) {
    prompt += `\nCooking Time: ${cookingTime} minutes`;
  }
  
  // Add time limit if provided
  if (timeLimit && timeLimit !== 'no-limit') {
    const timeLimitMinutes = timeLimit === '15' ? 15 : timeLimit === '30' ? 30 : timeLimit === '60' ? 60 : null;
    if (timeLimitMinutes) {
      prompt += `\nTime Constraint: Recipe must be completable in under ${timeLimitMinutes} minutes total (including prep and cooking). Focus on quick cooking methods, minimal prep, and efficient techniques.`;
    }
  }
  
  // Add difficulty if provided
  if (difficulty) {
    prompt += `\nDifficulty: ${difficulty}`;
  }
  
  // Add servings if provided and positive
  if (servings && servings > 0) {
    prompt += `\nServings: ${servings}`;
  }
  
  // Add custom prompt if provided
  if (customPrompt) {
    prompt += `\n\nAdditional Requirements: ${customPrompt}`;
  }
  
  // Add format instructions
  prompt += `\n\nPlease format the recipe in the following JSON structure:
  {
    "title": "${recipeTitle || 'Recipe Title'}",
    "description": "A brief description of the recipe",
    "cuisineName": "${cuisine !== 'any' && cuisine !== 'ingredient-based' ? cuisine : 'fusion or appropriate cuisine style'}",
    "cookTimeMinutes": cooking time in minutes (number),
    "prepTimeMinutes": prep time in minutes (number),
    "difficulty": "Easy|Medium|Hard",
    "servings": number of servings (number),
    "ingredients": [
      {
        "name": "ingredient name",
        "quantity": "amount",
        "unit": "measurement unit"
      }
    ],
    "steps": [
      {
        "description": "Step description",
        "time": optional time in minutes (number)
      }
    ],
    "nutritionalInfo": {
      "calories": calories per serving (number),
      "protein": protein in grams (number),
      "carbs": carbs in grams (number),
      "fat": fat in grams (number)
    },
    "cookingTips": [
      "Cooking tip 1",
      "Cooking tip 2"
    ],
    "tags": ["${cuisine !== 'any' && cuisine !== 'ingredient-based' ? cuisine.toLowerCase() : 'fusion'}", "other relevant tags"]
  }`;
  
  return prompt;
};

/**
 * Parses the Gemini API response into a Recipe object
 */
const parseGeminiResponse = (response: GeminiResponse): Recipe => {
  try {
    // Retrieve raw text from Gemini response
    const raw = response.candidates[0].content.parts[0].text.trim();
    let clean = raw;
    // Strip Markdown fences if present
    if (clean.startsWith('```')) {
      const firstNewLine = clean.indexOf('\n');
      const lastFence = clean.lastIndexOf('```');
      if (firstNewLine !== -1 && lastFence !== -1) {
        clean = clean.slice(firstNewLine + 1, lastFence).trim();
      }
    }
    // Locate the JSON object boundaries
    const start = clean.indexOf('{');
    const end = clean.lastIndexOf('}');
    if (start === -1 || end === -1) {
      console.error('Failed to locate JSON object in Gemini response:', raw);
      throw new Error('Failed to parse JSON from Gemini response');
    }
    const jsonString = clean.slice(start, end + 1);
          if (__DEV__) {
        console.log('Parsing JSON from Gemini:', jsonString);
      }
      const recipeData = JSON.parse(jsonString);
      if (__DEV__) {
        console.log('Parsed recipe data:', JSON.stringify(recipeData, null, 2));
      }

    // Ensure arrays are properly formatted and never undefined
    const ensureArray = (data: any): any[] => {
      if (Array.isArray(data)) return data;
      if (data === null || data === undefined) return [];
      return [data]; // If it's a single item, wrap it in an array
    };

    // Ensure ingredients have proper structure
    const ensureIngredients = (ingredients: any): any[] => {
      const ingredientArray = ensureArray(ingredients);
      return ingredientArray.map(ing => {
        if (typeof ing === 'string') {
          return { name: ing, quantity: '1', unit: '' };
        }
        return {
          name: ing.name || 'Unknown ingredient',
          quantity: ing.quantity || '1',
          unit: ing.unit || ''
        };
      });
    };

    // Ensure steps have proper structure
    const ensureSteps = (steps: any): any[] => {
      const stepsArray = ensureArray(steps);
      return stepsArray.map((step, index) => {
        if (typeof step === 'string') {
          return { description: step, time: undefined };
        }
        return {
          description: step.description || step.instruction || `Step ${index + 1}`,
          time: step.time || step.timeMinutes || undefined
        };
      });
    };

    // Create a recipe object from the parsed data
    const recipe: Recipe = {
      id: uuidv4(),
      title: recipeData.title || 'Untitled Recipe',
      description: recipeData.description || 'A delicious recipe',
      image: `https://source.unsplash.com/random/?${encodeURIComponent((recipeData.title || 'food').toLowerCase().replace(/[^a-z0-9]/gi, '+'))}`,
      heroImage: `https://source.unsplash.com/random/?${encodeURIComponent((recipeData.title || 'food').toLowerCase().replace(/[^a-z0-9]/gi, '+'))}`,
      prepTime: recipeData.prepTimeMinutes || 15,
      cookTime: recipeData.cookTimeMinutes || 30,
      totalTime: (recipeData.prepTimeMinutes || 15) + (recipeData.cookTimeMinutes || 30),
      servings: recipeData.servings || 4,
      difficulty: recipeData.difficulty || 'Medium',
      rating: 4.5 + Math.random() * 0.5, // Random rating between 4.5 and 5.0
      tags: ensureArray(recipeData.tags),
      ingredients: ensureIngredients(recipeData.ingredients),
      steps: ensureSteps(recipeData.steps),
      nutritionalInfo: {
        calories: recipeData.nutritionalInfo?.calories || 0,
        protein: recipeData.nutritionalInfo?.protein || 0,
        carbs: recipeData.nutritionalInfo?.carbs || 0,
        fat: recipeData.nutritionalInfo?.fat || 0,
        sugar: recipeData.nutritionalInfo?.sugar || 0,
        sodium: recipeData.nutritionalInfo?.sodium || 0,
        fiber: recipeData.nutritionalInfo?.fiber || 0
      },
      cuisineType: recipeData.cuisineName || 'Other',
      mealType: ['other'],
      dietaryInfo: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    return recipe;
  } catch (error) {
    console.error('Error parsing Gemini response:', error);
    throw new Error('Failed to parse Gemini response');
  }
};

/**
 * Generates a mock recipe for testing or when the API is unavailable
 */
const generateMockRecipe = (params: RecipeGenerationParams): Recipe => {
  // Handle seasonal recipe generation
  if (params.seasonalContext && params.recipeTitle) {
    const { season, dish } = params.seasonalContext;
    const seasonalIngredients = dish?.ingredients || [];
    
    if (__DEV__) {
    console.log('ðŸ”„ Generating seasonal mock recipe for:', params.recipeTitle, 'season:', season);
  }
    
    const seasonName = season && typeof season === 'string' ? season.charAt(0).toUpperCase() + season.slice(1) : 'Seasonal';
    
    return {
      id: uuidv4(),
      title: params.recipeTitle,
      description: `A delicious ${season || 'seasonal'} recipe featuring seasonal ingredients. This recipe celebrates the best flavors of ${season || 'the current'} season with fresh, locally-sourced ingredients.`,
      cuisineType: `Seasonal ${seasonName}`,
      mealType: ['seasonal'],
      dietaryInfo: [],
      prepTime: 15,
      cookTime: 25,
      totalTime: 40,
      servings: params.servings || 4,
      difficulty: 'Medium',
      rating: 4.5,
      tags: ['seasonal', season || 'fresh', 'fresh', 'healthy', 'local'],
      ingredients: seasonalIngredients.length > 0 ? seasonalIngredients.map((ing: any) => ({
        name: typeof ing === 'string' ? ing : ing.name || ing,
        quantity: '2',
        unit: 'cups'
      })) : [
        { name: `Fresh ${season || 'seasonal'} produce`, quantity: '3', unit: 'cups' },
        { name: 'Extra virgin olive oil', quantity: '3', unit: 'tablespoons' },
        { name: 'Fresh herbs', quantity: '2', unit: 'tablespoons' },
        { name: 'Sea salt', quantity: '1', unit: 'teaspoon' },
        { name: 'Black pepper', quantity: '1/2', unit: 'teaspoon' }
      ],
      steps: [
        { 
          description: `Prepare your fresh ${season || 'seasonal'} ingredients by washing and cutting them into appropriate sizes. Take time to appreciate the seasonal quality and freshness.`, 
          time: 8 
        },
        { 
          description: `Heat olive oil in a large skillet or pan over medium heat. The oil should be warm but not smoking.`, 
          time: 3 
        },
        { 
          description: `Add the prepared seasonal ingredients to the pan. Cook gently to preserve their natural flavors and textures, typical of ${season || 'seasonal'} cooking.`, 
          time: 12 
        },
        { 
          description: `Season with fresh herbs, salt, and pepper. Adjust seasoning to complement the natural flavors of the ${season || 'seasonal'} ingredients.`, 
          time: 2 
        },
        { 
          description: `Remove from heat and serve immediately while the ${season || 'seasonal'} flavors are at their peak. Garnish with additional fresh herbs if desired.`, 
          time: 5 
        }
      ],
      nutritionalInfo: {
        calories: 180,
        protein: 4,
        carbs: 22,
        fat: 9
      },
      cookingTips: [
        `Choose the freshest ${season || 'seasonal'} ingredients available for the best flavor`,
        `Don't overcook seasonal produce to maintain their natural textures`,
        `Taste and adjust seasoning to complement the ${season || 'seasonal'} flavors`
      ],
      isAiGenerated: false
    };
  }

  // Original mock recipe generation for non-seasonal recipes
  const mockRecipes = [
    {
      title: 'Classic Pasta Primavera',
      description: 'A light and fresh pasta dish with seasonal vegetables.',
      cuisineType: params.cuisine || 'Italian',
      prepTime: 15,
      cookTime: 20,
      ingredients: [
        { name: 'Pasta', quantity: '1', unit: 'pound' },
        { name: 'Mixed vegetables', quantity: '2', unit: 'cups' },
        { name: 'Olive oil', quantity: '3', unit: 'tablespoons' },
        { name: 'Garlic', quantity: '3', unit: 'cloves' }
      ]
    },
    {
      title: 'Hearty Vegetable Soup',
      description: 'A warming and nutritious soup perfect for any season.',
      cuisineType: params.cuisine || 'American',
      prepTime: 20,
      cookTime: 30,
      ingredients: [
        { name: 'Mixed vegetables', quantity: '4', unit: 'cups' },
        { name: 'Vegetable broth', quantity: '6', unit: 'cups' },
        { name: 'Onion', quantity: '1', unit: 'large' },
        { name: 'Herbs', quantity: '2', unit: 'teaspoons' }
      ]
    }
  ];

  const selectedMock = mockRecipes[Math.floor(Math.random() * mockRecipes.length)];

  return {
    id: uuidv4(),
    title: params.recipeTitle || selectedMock.title,
    description: selectedMock.description,
    cuisineType: selectedMock.cuisineType,
    mealType: [params.mealType || 'main'],
    dietaryInfo: [],
    prepTime: selectedMock.prepTime,
    cookTime: selectedMock.cookTime,
    totalTime: selectedMock.prepTime + selectedMock.cookTime,
    servings: params.servings || 4,
    difficulty: 'Medium',
    rating: 4.2,
    tags: [selectedMock.cuisineType.toLowerCase(), 'quick', 'easy'],
    ingredients: selectedMock.ingredients,
    steps: [
      { description: 'Prepare all ingredients by washing and chopping as needed.', time: 10 },
      { description: 'Heat oil in a large pan and begin cooking the base ingredients.', time: 5 },
      { description: 'Add remaining ingredients and cook according to recipe requirements.', time: 15 },
      { description: 'Season to taste and serve hot.', time: 5 }
    ],
    nutritionalInfo: {
      calories: 250,
      protein: 8,
      carbs: 35,
      fat: 10
    },
    cookingTips: [
      'Use fresh ingredients for the best flavor',
      'Don\'t overcook vegetables to maintain their texture',
      'Taste and adjust seasoning before serving'
    ],
    isAiGenerated: false
  };
};

/**
 * Generates an image description for a recipe that can be used with Runware API
 */
export const generateImagePrompt = async (recipe: Recipe): Promise<string> => {
  try {
    if (ENV.USE_MOCK_GEMINI) {
      return `A delicious plate of ${recipe.title}, beautifully presented on a wooden table with garnish and proper lighting, food photography style, high resolution, appetizing`;
    }
    
    const prompt = `Create a detailed image description for a food photography prompt of this recipe: "${recipe.title}". 
    The description should be suitable for an AI image generation model to create a realistic, appetizing photo of the dish.
    Include details about presentation, plating, background, lighting, and styling.
    Keep the description under 100 words and focus on making the food look delicious.
    Only respond with the image description text, no other text.`;
    
    const response = await generateText(prompt);
    const text = response.trim();
    
    return text;
  } catch (error) {
    console.error('Error generating image prompt:', error);
    return `A delicious plate of ${recipe.title}, beautifully presented on a wooden table with garnish and proper lighting, food photography style, high resolution, appetizing`;
  }
};

/**
 * Generate text using Gemini API - simplified version for general text generation
 * This function is used by various services that need text generation
 * @param prompt - The prompt to generate text from
 * @returns The generated text
 */
export const generateTextWithGemini = async (prompt: string): Promise<string> => {
  try {
    return await generateText(prompt);
  } catch (error) {
    console.error('Error in generateTextWithGemini:', error);
    // Return a simple error message instead of throwing
    return "I'm sorry, I couldn't generate a response at this time.";
  }
};

/**
 * Generate dynamic AI recipe suggestions using Gemini
 * @param params - Parameters for generating suggestions
 * @returns Promise with personalized recipe suggestion
 */
export interface AISuggestionParams {
  mealType: 'breakfast' | 'lunch' | 'dinner' | 'snacks';
  userPreferences?: {
    dietaryProfile?: string;
    cuisineTypes?: string[];
    spiceLevel?: string;
    cookingSkill?: string;
    favoriteIngredients?: string[];
    cookingTimeLimit?: number;
    allergies?: string[];
  };
  timeOfDay?: number;
  excludeRecipes?: string[]; // To avoid repeating suggestions
}

export interface AISuggestionResponse {
  title: string;
  cookTime: string;
  cuisine: string;
  difficulty: string;
  tags: string[];
  description?: string;
}

export const generateAISuggestion = async (params: AISuggestionParams): Promise<AISuggestionResponse> => {
  if (ENV.USE_MOCK_GEMINI) {
    return generateMockAISuggestion(params);
  }

  try {
    const prompt = createAISuggestionPrompt(params);
    const response = await generateText(prompt);
    return parseAISuggestionResponse(response);
  } catch (error) {
    console.error('Error generating AI suggestion:', error);
    // Fallback to mock suggestion
    return generateMockAISuggestion(params);
  }
};

/**
 * Create a prompt for AI suggestion generation
 */
const createAISuggestionPrompt = (params: AISuggestionParams): string => {
  const { mealType, userPreferences, timeOfDay, excludeRecipes } = params;
  
  let prompt = `You are a world-class chef and culinary expert. I need you to suggest ONE perfect ${mealType} recipe that is specifically tailored to the user's preferences and current context.

MEAL TYPE: ${mealType.toUpperCase()}`;
  
  // Add specific meal type guidance
  if (mealType === 'breakfast') {
    prompt += `
- Focus on energizing, nutritious morning meals
- Consider options like eggs, pancakes, oats, smoothie bowls, toast variations
- Should be ready in 5-30 minutes typically`;
  } else if (mealType === 'lunch') {
    prompt += `
- Focus on balanced, satisfying midday meals
- Consider salads, sandwiches, bowls, light pasta, wraps, soups
- Should be ready in 15-45 minutes typically`;
  } else if (mealType === 'dinner') {
    prompt += `
- Focus on hearty, comforting evening meals
- Consider main dishes with protein, sides, pasta, stir-fries, roasts
- Should be ready in 20-60 minutes typically`;
  } else if (mealType === 'snacks') {
    prompt += `
- Focus on light, satisfying snacks or appetizers
- Consider dips, small bites, finger foods, healthy snacks
- Should be ready in 5-20 minutes typically`;
  }
  
  // Add time context with more specific guidance
  if (timeOfDay !== undefined) {
    if (timeOfDay >= 5 && timeOfDay < 11) {
      prompt += `\n\nTIME CONTEXT: Morning (${timeOfDay}:00)
- Suggest something energizing and fresh to start the day
- Consider lighter, easier-to-digest options
- Think about coffee/tea pairings`;
    } else if (timeOfDay >= 11 && timeOfDay < 16) {
      prompt += `\n\nTIME CONTEXT: Afternoon (${timeOfDay}:00)
- Suggest something satisfying and balanced for midday energy
- Consider protein-rich options to sustain energy
- Think about work-friendly or family-friendly meals`;
    } else if (timeOfDay >= 16 && timeOfDay < 22) {
      prompt += `\n\nTIME CONTEXT: Evening (${timeOfDay}:00)
- Suggest something comforting and hearty for dinner time
- Consider warming, satisfying options for end of day
- Think about family-style or relaxing meals`;
    } else {
      prompt += `\n\nTIME CONTEXT: Late night/early morning (${timeOfDay}:00)
- Suggest something light and easy to digest
- Consider quick, simple options that won't disrupt sleep
- Think about comfort foods that are gentle`;
    }
  }

  // Add detailed user preferences
  if (userPreferences) {
    prompt += `
    
USER PREFERENCES:`;
    
    if (userPreferences.dietaryProfile) {
      prompt += `\n- Dietary Profile: ${userPreferences.dietaryProfile}`;
    }
    
    if (userPreferences.cuisineTypes && userPreferences.cuisineTypes.length > 0) {
      prompt += `\n- Preferred Cuisines: ${userPreferences.cuisineTypes.join(', ')}`;
    }
    
    if (userPreferences.spiceLevel) {
      prompt += `\n- Spice Level: ${userPreferences.spiceLevel}`;
    }
    
    if (userPreferences.cookingSkill) {
      prompt += `\n- Cooking Skill: ${userPreferences.cookingSkill}`;
    }
    
    if (userPreferences.favoriteIngredients && userPreferences.favoriteIngredients.length > 0) {
      prompt += `\n- Favorite Ingredients: ${userPreferences.favoriteIngredients.join(', ')}`;
    }
    
    if (userPreferences.cookingTimeLimit) {
      prompt += `\n- Time Limit: ${userPreferences.cookingTimeLimit} minutes maximum`;
    }
    
    if (userPreferences.allergies && userPreferences.allergies.length > 0) {
      prompt += `\n- ALLERGIES (MUST AVOID): ${userPreferences.allergies.join(', ')}`;
    }
  }

  // Add exclusions
  if (excludeRecipes && excludeRecipes.length > 0) {
    prompt += `\n\nRECIPES TO AVOID (already suggested recently): ${excludeRecipes.join(', ')}`;
  }

  prompt += `

RESPONSE FORMAT: Please respond with ONLY a valid JSON object in this exact format:
{
  "title": "Recipe Name (be creative and appetizing)",
  "cookTime": "X minutes",
  "cuisine": "Cuisine type",
  "difficulty": "Easy|Medium|Hard",
  "description": "Brief 1-2 sentence description focusing on flavors and appeal",
  "tags": ["tag1", "tag2", "tag3"]
}

IMPORTANT RULES:
- Make the title appetizing and specific (not generic)
- Consider the time of day and meal type in your suggestion
- Respect all dietary restrictions and allergies
- Choose recipes that match the user's cooking skill level
- If no cuisine preference is specified, suggest diverse options
- Make it sound delicious and appealing
- Only respond with the JSON object, no additional text`;

  return prompt;
};

/**
 * Parse AI suggestion response
 */
const parseAISuggestionResponse = (response: string): AISuggestionResponse => {
  try {
    // Clean the response to extract JSON
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No JSON found in response');
    }
    
    const cleanedResponse = jsonMatch[0];
    const suggestion = JSON.parse(cleanedResponse);
    
    return {
      title: suggestion.title || 'Delicious Recipe',
      cookTime: suggestion.cookTime || '30 minutes',
      cuisine: suggestion.cuisine || 'International',
      difficulty: suggestion.difficulty || 'Medium',
      tags: Array.isArray(suggestion.tags) ? suggestion.tags : ['delicious'],
      description: suggestion.description || 'A wonderful meal to enjoy'
    };
  } catch (error) {
    console.error('Error parsing AI suggestion response:', error);
    // Return a fallback suggestion
    return {
      title: 'Chef\'s Special',
      cookTime: '25 minutes',
      cuisine: 'Fusion',
      difficulty: 'Medium',
      tags: ['special', 'tasty'],
      description: 'A delightful dish crafted with care'
    };
  }
};

/**
 * Generate mock AI suggestion for testing
 */
// Alias for generateAISuggestion to match home screen import
export const generateSmartSuggestion = generateAISuggestion;

const generateMockAISuggestion = (params: AISuggestionParams): AISuggestionResponse => {
  const mockSuggestions = {
    breakfast: [
      {
        title: "Fluffy Banana Pancakes with Maple Syrup",
        cookTime: "15 minutes",
        cuisine: "American",
        difficulty: "Easy",
        tags: ["sweet", "fluffy", "morning"],
        description: "Light and airy pancakes with fresh banana slices and warm maple syrup."
      },
      {
        title: "Avocado Toast with Poached Egg",
        cookTime: "10 minutes",
        cuisine: "Modern",
        difficulty: "Medium",
        tags: ["healthy", "protein", "fresh"],
        description: "Creamy avocado on artisan bread topped with a perfectly poached egg."
      }
    ],
    lunch: [
      {
        title: "Mediterranean Quinoa Bowl",
        cookTime: "20 minutes",
        cuisine: "Mediterranean",
        difficulty: "Easy",
        tags: ["healthy", "grain", "fresh"],
        description: "Nutritious quinoa with fresh vegetables, olives, and tangy feta cheese."
      },
      {
        title: "Grilled Chicken Caesar Wrap",
        cookTime: "15 minutes",
        cuisine: "American",
        difficulty: "Easy",
        tags: ["protein", "handheld", "satisfying"],
        description: "Tender grilled chicken with crisp romaine and creamy Caesar dressing in a tortilla."
      }
    ],
    dinner: [
      {
        title: "Honey Garlic Salmon with Roasted Vegetables",
        cookTime: "35 minutes",
        cuisine: "Asian-Fusion",
        difficulty: "Medium",
        tags: ["seafood", "healthy", "flavorful"],
        description: "Glazed salmon fillet with colorful roasted seasonal vegetables."
      },
      {
        title: "Creamy Mushroom Risotto",
        cookTime: "45 minutes",
        cuisine: "Italian",
        difficulty: "Hard",
        tags: ["creamy", "comfort", "sophisticated"],
        description: "Rich and creamy arborio rice with wild mushrooms and parmesan cheese."
      }
    ],
    snacks: [
      {
        title: "Crispy Chickpea Bites with Tahini Dip",
        cookTime: "25 minutes",
        cuisine: "Middle Eastern",
        difficulty: "Easy",
        tags: ["crunchy", "protein", "healthy"],
        description: "Seasoned roasted chickpeas with creamy tahini dipping sauce."
      },
      {
        title: "Caprese Skewers with Balsamic Glaze",
        cookTime: "10 minutes",
        cuisine: "Italian",
        difficulty: "Easy",
        tags: ["fresh", "elegant", "quick"],
        description: "Cherry tomatoes, mozzarella, and basil drizzled with balsamic reduction."
      }
    ]
  };

  const suggestions = mockSuggestions[params.mealType] || mockSuggestions.lunch;
  const randomSuggestion = suggestions[Math.floor(Math.random() * suggestions.length)];
  
  return randomSuggestion;
};