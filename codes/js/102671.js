//@ts-check

/**
 * CSS display mode.
 * @typedef {'visible' | 'block' | 'inline' | 'inline-block' | 'flex' | 'inline-flex' | 'grid' | 'inline-grid' | 'grid' | 'inline-grid' | 'flow-root' | 'inherit' | 'initial' | 'revert' | 'revert-layer' | 'unset'} CSSDisplayMode
 */

/**
 * Types of box-sizing.
 * @typedef {'border-box' | 'content-box'  | 'inherit' | 'initial' | 'revert' | 'revert-layer' | 'unset'} BoxSizingType
 */

/**
 * Types of alignment.
 * @typedef {'center' | 'start' | 'end' | 'flex-start' | 'flex-end' | 'left' | 'right' | 'normal' | 'space-between' | 'space-around' | 'space-evenly' | 'stretch' | 'safe center' | 'unsafe center' | 'inherit' | 'initial' | 'revert' | 'revert-layer' | 'unset'} HTMLAlignment
 */

/**
 * Types of position.
 * @typedef {'static' | 'absolute' | 'relative' | 'fixed' | 'sticky' | 'inherit' | 'initial' | 'revert' | 'revert-layer' | 'unset'} PositionType
 */

/**
 * Types of border style.
 * @typedef {'none' | 'hidden' | 'dotted' | 'dashed' | 'solid' | 'double' | 'groove' | 'ridge' | 'inset' | 'outset' | 'inherit' | 'initial' | 'revert' | 'revert-layer' | 'unset'} BorderStyleType
 */

/**
 * Types of border collapse state.
 * @typedef {'collapse' | 'separate' | 'inset' | 'outset' | 'inherit' | 'initial' | 'revert' | 'revert-layer' | 'unset'} BorderCollapseState
 */

/**
 * Types of content overflow state.
 * @typedef {'visible' | 'hidden' | 'clip' | 'scroll' | 'auto'} OverflowState
 */

// Generated by Gemini 2.5 Flash

const invalidHex = new Error("Given value contains invalid hex value.");

/**
 * @param {string} hex
 * @returns {object|null}
 */
function hexToRgbaObject(hex) {
    if (!hex || typeof hex !== "string") {
        throw invalidHex;
    }

    if (hex[0] !== "#") {
        throw invalidHex;
    }

    const cleanHex = hex.startsWith("#") ? hex.slice(1) : hex;

    let r, g, b, a;

    if (cleanHex.length === 3) {
        r = parseInt(cleanHex[0] + cleanHex[0], 16);
        g = parseInt(cleanHex[1] + cleanHex[1], 16);
        b = parseInt(cleanHex[2] + cleanHex[2], 16);
        a = 1;
    } else if (cleanHex.length === 6) {
        r = parseInt(cleanHex.substring(0, 2), 16);
        g = parseInt(cleanHex.substring(2, 4), 16);
        b = parseInt(cleanHex.substring(4, 6), 16);
        a = 1;
    } else if (cleanHex.length === 8) {
        r = parseInt(cleanHex.substring(0, 2), 16);
        g = parseInt(cleanHex.substring(2, 4), 16);
        b = parseInt(cleanHex.substring(4, 6), 16);
        a = parseInt(cleanHex.substring(6, 8), 16) / 255;
    } else {
        throw invalidHex;
    }

    if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {
        throw invalidHex;
    }

    const rgbaObject = { r, g, b };
    if (cleanHex.length === 8) {
        rgbaObject.a = parseFloat(a.toFixed(2));
    }

    return rgbaObject;
}

/**
 * @param {{r: number, g: number, b: number}} param0
 */
function rgbToHsl({ r, g, b }) {
    r /= 255;
    g /= 255;
    b /= 255;

    let max = Math.max(r, g, b),
        min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0;
    } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }

        h /= 6;
    }

    return { h: h * 360, s: s * 100, l: l * 100 };
}

/**
 * @param {{h: number, s: number, l: number}} param0
 */
function hslToRgb({ h, s, l }) {
    h /= 360;
    s /= 100;
    l /= 100;

    let r, g, b;

    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;

        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255),
    };
}

/**
 * @param {object} col
 * @param {number} col.r
 * @param {number} col.g
 * @param {number} col.b
 * @param {object} [options]
 * @param {number} [options.bgHoverLightness=8]
 * @param {number} [options.bgHoverSaturation=0]
 * @param {number} [options.bgPressedLightness=-15]
 * @param {number} [options.bgPressedSaturation=-10]
 * @param {number} [options.borderNormalLightness=-10]
 * @param {number} [options.borderNormalSaturation=0]
 * @param {number} [options.borderHoverLightness=-5]
 * @param {number} [options.borderHoverSaturation=0]
 * @param {number} [options.borderPressedLightness=-20]
 * @param {number} [options.borderPressedSaturation=-15]
 */
function getButtonStateColors(col, options = {}) {
    const {
        bgHoverLightness = 8,
        bgHoverSaturation = 0,
        bgPressedLightness = -15,
        bgPressedSaturation = -10,

        borderNormalLightness = -10,
        borderNormalSaturation = 0,
        borderHoverLightness = -5,
        borderHoverSaturation = 0,
        borderPressedLightness = -20,
        borderPressedSaturation = -15,
    } = options;

    const sourceHsl = rgbToHsl(col);
    const { h, s, l } = sourceHsl;

    /**
     * @param {number} baseH
     * @param {number} baseS
     * @param {number} baseL
     * @param {number} lightnessAdj
     * @param {number} saturationAdj
     */
    const calculateColor = (
        baseH,
        baseS,
        baseL,
        lightnessAdj,
        saturationAdj,
    ) => {
        const newL = Math.max(0, Math.min(100, baseL + lightnessAdj));
        const newS = Math.max(0, Math.min(100, baseS + saturationAdj));
        return hslToRgb({
            h: baseH,
            s: newS,
            l: newL,
        });
    };

    const normalBgColor = col;

    const normalBorderColor = calculateColor(
        h,
        s,
        l,
        borderNormalLightness,
        borderNormalSaturation,
    );

    const hoverBgColor = calculateColor(
        h,
        s,
        l,
        bgHoverLightness,
        bgHoverSaturation,
    );

    const hoverBorderColor = calculateColor(
        h,
        s,
        l,
        borderHoverLightness,
        borderHoverSaturation,
    );

    const pressedBgColor = calculateColor(
        h,
        s,
        l,
        bgPressedLightness,
        bgPressedSaturation,
    );

    const pressedBorderColor = calculateColor(
        h,
        s,
        l,
        borderPressedLightness,
        borderPressedSaturation,
    );

    return {
        normal: {
            bg: normalBgColor,
            border: normalBorderColor,
        },
        hover: {
            bg: hoverBgColor,
            border: hoverBorderColor,
        },
        pressed: {
            bg: pressedBgColor,
            border: pressedBorderColor,
        },
    };
}

/**
 * @param {string} str
 * @returns {boolean}
 */
function hasSpecialAsciiCharacters(str) {
    if (typeof str !== "string") {
        return false;
    }
    const specialAsciiRegex = /[^A-Za-z0-9 ]/;

    for (let i = 0; i < str.length; i++) {
        const char = str[i];
        if (char === "-") continue;
        if (char === "_") continue;
        const asciiValue = char.charCodeAt(0);

        if (asciiValue >= 0 && asciiValue <= 127) {
            if (specialAsciiRegex.test(char)) {
                return true;
            }
        }
    }
    return false;
}

class CssManager {
    static #instance = null; // Private static instance for Singleton pattern
    #styleElement = null;
    #styleCounter = 0;
    #currentStyles = {}; // Stores styles for the currently building class
    #currentOptions = {
        mediaQueries: {},
        pseudoClasses: {},
    };

    /**
     * Private constructor to enforce Singleton pattern.
     */
    constructor() {
        if (CssManager.#instance) {
            return CssManager.#instance;
        }

        this.#initializeStyleElement();
        CssManager.#instance = this;
    }

    /**
     * Initializes the style element if it doesn't exist.
     */
    #initializeStyleElement() {
        if (!this.#styleElement) {
            this.#styleElement = document.createElement("style");
            this.#styleElement.type = "text/css";
            document.head.appendChild(this.#styleElement);
        }
    }

    /**
     * Returns the singleton instance of CssManager.
     * @returns {CssManager} The singleton instance.
     */
    static getInstance() {
        if (!CssManager.#instance) {
            CssManager.#instance = new CssManager();
        }
        return CssManager.#instance;
    }

    /**
     * Generates a unique class name.
     * @param {string} [prefix='styled-block-'] - Prefix for the class name.
     * @returns {string} A unique class name.
     */
    #generateClassName(prefix = "dandelion-") {
        this.#styleCounter++;
        return `${prefix}${this.#styleCounter}`;
    }

    /**
     * Converts a style object into CSS rules.
     * @param {Object} styles - The style properties object (e.g., { color: 'red', fontSize: '16px' }).
     * @returns {string} CSS rules string.
     */
    #styleObjectToCssString(styles) {
        let cssString = "";
        for (const prop in styles) {
            if (Object.prototype.hasOwnProperty.call(styles, prop)) {
                const value = styles[prop];
                // Convert camelCase to kebab-case
                const cssProp = prop.replace(
                    /([a-z0-9]|(?=[A-Z]))([A-Z])/g,
                    "$1-$2",
                ).toLowerCase();
                cssString += `  ${cssProp}: ${value};\n`;
            }
        }
        return cssString;
    }

    /**
     * Starts a new style definition. Clears any previous chained styles.
     * @param {Object} baseStyles - The base styles for the class.
     * @returns {CssManager} The CssManager instance for chaining.
     */
    define(baseStyles) {
        this.#currentStyles = baseStyles;
        this.#currentOptions = {
            mediaQueries: {},
            pseudoClasses: {},
        };
        return this; // Enable chaining
    }

    /**
     * Adds pseudo-class styles to the current definition.
     * @param {Object} pseudoClasses - Object where keys are pseudo-class names (e.g., 'hover', 'active') and values are style objects.
     * @returns {CssManager} The CssManager instance for chaining.
     */
    addPseudoClasses(pseudoClasses) {
        Object.assign(this.#currentOptions.pseudoClasses, pseudoClasses);
        return this; // Enable chaining
    }

    /**
     * Adds media query styles to the current definition.
     * @param {Object} mediaQueries - Object where keys are media queries (e.g., '@media (max-width: 768px)') and values are style objects.
     * @returns {CssManager} The CssManager instance for chaining.
     */
    addMediaQueries(mediaQueries) {
        Object.assign(this.#currentOptions.mediaQueries, mediaQueries);
        return this; // Enable chaining
    }

    /**
     * Finalizes the style definition, appends it to the style block, and returns the class name.
     * @returns {string} The generated class name.
     */
    createWithoutName() {
        return this.create();
    }

    /**
     * Finalizes the style definition, appends it to the style block, and returns the class name.
     * @param {string} [customName]
     * @returns {string} The generated class name.
     */
    createWithName(customName) {
        return this.create(customName || this.#generateClassName());
    }

    /**
     * Finalizes the style definition, appends it to the style block, and returns the class name.
     * @param {string} [customName]
     * @returns {string} The generated class name.
     */
    create(customName) {
        const className = customName
            ? (hasSpecialAsciiCharacters(customName)
                ? customName
                : ("." + customName))
            : "";
        let newCssRules = "";

        // Base styles
        if (Object.keys(this.#currentStyles).length) {
            newCssRules += `${className} {\n${
                this.#styleObjectToCssString(this.#currentStyles)
            }}\n\n`;
        }

        // Pseudo-class styles
        for (const pseudoClass in this.#currentOptions.pseudoClasses) {
            if (
                Object.prototype.hasOwnProperty.call(
                    this.#currentOptions.pseudoClasses,
                    pseudoClass,
                )
            ) {
                newCssRules += `${className}:${pseudoClass} {\n${
                    this.#styleObjectToCssString(
                        this.#currentOptions.pseudoClasses[pseudoClass],
                    )
                }}\n\n`;
            }
        }

        // Media query styles
        for (const query in this.#currentOptions.mediaQueries) {
            if (
                Object.prototype.hasOwnProperty.call(
                    this.#currentOptions.mediaQueries,
                    query,
                )
            ) {
                newCssRules += `${query} {\n`;
                newCssRules += `  ${className} {\n${
                    this.#styleObjectToCssString(
                        this.#currentOptions.mediaQueries[query],
                    )
                }  }\n`;
                newCssRules += `}\n\n`;
            }
        }

        this.#styleElement.textContent += newCssRules;

        // Clear current state for the next definition
        this.#currentStyles = {};
        this.#currentOptions = { mediaQueries: {}, pseudoClasses: {} };

        return customName;
    }
}

const cssManager = CssManager.getInstance();

class CssProperty {
    _export() {
        return {};
    }
}

/** @description Set platform-specific UI elements. */
class Appearance extends CssProperty {
    /**
     * @param {string} type
     */
    constructor(type) {
        super();
        this.type = type;
    }

    _export() {
        return {
            appearance: this.type,
        };
    }
}

class Size extends CssProperty {
    /**
     * @override
     * @param {string} size
     */
    /**
     * @override
     * @param {string} width
     * @param {string} height
     */
    /**
     * @param {string} width
     * @param {string} [height]
     */
    constructor(width, height) {
        super();
        if (typeof height === "undefined") {
            height = width;
        }
        this.width = width;
        this.height = height;
    }

    _export() {
        return {
            width: this.width,
            height: this.height,
        };
    }
}

/** @description Set box-sizing for this element. */
class BoxSizing extends CssProperty {
    /**
     * @param {BoxSizingType} type
     */
    constructor(type) {
        super();
        this.type = type;
    }

    _export() {
        return {
            boxSizing: this.type,
        };
    }
}

class QuadSide extends CssProperty {
    /**
     * @overload
     * @param {string|number} size
     */
    /**
     * @overload
     * @param {string|number} vertical
     * @param {string|number} horizontal
     */
    /**
     * @overload
     * @param {string|number} top
     * @param {string|number} horizontal
     * @param {string|number} bottom
     */
    /**
     * @overload
     * @param {string|number} top
     * @param {string|number} right
     * @param {string|number} bottom
     * @param {string|number} left
     */
    /**
     * @param {string|number} top
     * @param {string|number} [right]
     * @param {string|number} [bottom]
     * @param {string|number} [left]
     */
    constructor(top, right, bottom, left) {
        super();
        if (typeof right === "undefined") {
            right = top;
            left = top;
            bottom = top;
            left = top;
        } else if (typeof bottom === "undefined") {
            bottom = top;
            left = right;
        } else if (typeof left === "undefined") {
            left = right;
        }
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
    }

    _getSides() {
        return `${this.top} ${this.right} ${this.bottom} ${this.left}`;
    }
}

/**
 * @description Set margin (how far this element will be from other elements).
 */
class Margin extends QuadSide {
    _export() {
        return {
            margin: this._getSides(),
        };
    }
}

/**
 * @description Set content padding from the element to its content inside the area.
 */
class Padding extends QuadSide {
    _export() {
        return {
            padding: this._getSides(),
        };
    }
}

/**
 * @description Set horizontal alignment for contents inside.
 */
class JustifyContent extends CssProperty {
    /**
     * @param {HTMLAlignment} justify
     */
    constructor(justify) {
        super();
        this.justify = justify;
    }

    _export() {
        return {
            justifyContent: this.justify,
            textAlign: this.justify,
        };
    }
}

/**
 * @description Set horizontal alignment for contents inside.
 */
class AlignItems extends CssProperty {
    /**
     * @param {HTMLAlignment} align
     */
    constructor(align) {
        super();
        this.align = align;
    }

    _export() {
        return {
            alignItems: this.align,
        };
    }
}

/**
 * @description Set how this element will be placed on the screen.
 */
class Anchor extends CssProperty {
    constructor() {
        super();
        this.properties = {};
    }

    /**
     * Set value of the top position where this element will be.
     * @param {...string} values
     */
    top(...values) {
        this.properties.top = values.join(" ");
        return this;
    }

    /**
     * Set value of the right position where this element will be.
     * @param {...string} values
     */
    right(...values) {
        this.properties.right = values.join(" ");
        return this;
    }

    /**
     * Set value of the bottom position where this element will be.
     * @param {...string} values
     */
    bottom(...values) {
        this.properties.bottom = values.join(" ");
        return this;
    }

    /**
     * Set value of the left position where this element will be.
     * @param {...string} values
     */
    left(...values) {
        this.properties.left = values.join(" ");
        return this;
    }

    _export() {
        return this.properties;
    }
}

class Position extends Anchor {
    /**
     * @param {PositionType} posType
     */
    constructor(posType) {
        super();
        this.properties.position = posType;
    }
}

/**
 * @description Floating element, behaves as the element will be put on the screen exactly as said, and will not move when the screen scrolls.
 */
class FixedElement extends Position {
    constructor() {
        super("fixed");
    }
}

/**
 * @description Sticky element, behaves as the element will follow viewport when the document gets scrolled.
 */
class StickyElement extends Position {
    constructor() {
        super("sticky");
    }
}

/**
 * Element display modes.
 */
class DisplayMode extends CssProperty {
    /**
     * @param {CSSDisplayMode} mode
     */
    constructor(mode) {
        super();
        if (mode === "visible") {
            mode = "block";
        }
        this.mode = mode;
    }

    _export() {
        return {
            display: this.mode,
        };
    }
}

/**
 * @description Set Z-index for this element
 */
class ZIndex extends CssProperty {
    /**
     * @param {number} depth
     */
    constructor(depth) {
        super();
        this.depth = depth;
    }

    /** Use toolbar-level depth for this element (128). */
    toolbar() {
        this.depth = 128;
        return this;
    }

    /** Use dialog-level depth for this element (256). */
    dialog() {
        this.depth = 256;
    }

    _export() {
        return {
            zIndex: `${this.depth}`,
        };
    }
}

/**
 * @description Set Foreground/text colour.
 */
class ForegroundColor extends CssProperty {
    /**
     * @param {string} col
     */
    constructor(col) {
        super();
        this.col = col;
    }

    _export() {
        return {
            color: this.col,
        };
    }
}

/**
 * @description Set background colour.
 */
class BackgroundColor extends CssProperty {
    /**
     * @param {string} col
     */
    constructor(col) {
        super();
        this.col = col;
    }

    _export() {
        return {
            backgroundColor: this.col,
        };
    }
}

/** @description Set background image. */
class BackgroundImage extends CssProperty {
    /**
     * @param {string} location
     */
    constructor(location) {
        super();
        this.location = location;
    }

    _export() {
        return {
            backgroundImage: this.location,
        };
    }
}

/** @description Set background size or type. */
class BackgroundSize extends CssProperty {
    /**
     * @param {string} s
     */
    constructor(s) {
        super();
        this.size = s;
    }

    _export() {
        return {
            backgroundSize: this.size,
        };
    }
}

/** @description Set border collapse status */
class BorderCollapse extends CssProperty {
    /** @param {BorderCollapseState} state */
    constructor(state) {
        super();
        this.state = state;
    }

    _export() {
        return {
            borderCollapse: this.state,
        };
    }
}

/**
 * @description Set border colour.
 */
class BorderColor extends CssProperty {
    /**
     * Set border colour.
     * @param {string} col
     */
    constructor(col) {
        super();
        this.col = col;
    }

    _export() {
        return {
            borderColor: this.col,
        };
    }
}

/**
 * @description Set border size.
 */
class BorderSize extends QuadSide {
    _export() {
        return {
            borderStyle: "solid",
            borderWidth: this._getSides(),
        };
    }
}

/** @description Set border style. */
class BorderStyle extends QuadSide {
    /**
     * @overload
     * @param {BorderStyleType} size
     */
    /**
     * @overload
     * @param {BorderStyleType} vertical
     * @param {BorderStyleType} horizontal
     */
    /**
     * @overload
     * @param {BorderStyleType} top
     * @param {BorderStyleType} horizontal
     * @param {BorderStyleType} bottom
     */
    /**
     * @overload
     * @param {BorderStyleType} top
     * @param {BorderStyleType} right
     * @param {BorderStyleType} bottom
     * @param {BorderStyleType} left
     */
    /**
     * @param {BorderStyleType} top
     * @param {BorderStyleType} [right]
     * @param {BorderStyleType} [bottom]
     * @param {BorderStyleType} [left]
     */
    constructor(top, right, bottom, left) {
        super(top, right, bottom, left);
    }

    _export() {
        return {
            borderStyle: this._getSides(),
        };
    }
}

/**
 * @description Set border radius (corner's roundness of an element).
 */
class BorderRadius extends QuadSide {
    _export() {
        return {
            borderRadius: this._getSides(),
        };
    }
}

/**
 * @description Set border colour.
 */
class OutlineColor extends CssProperty {
    /**
     * Set border colour.
     * @param {string} col
     */
    constructor(col) {
        super();
        this.col = col;
    }

    _export() {
        return {
            outlineColor: this.col,
        };
    }
}

/**
 * @description Set Outline size.
 */
class OutlineSize extends CssProperty {
    /**
     * Set outline size.
     * @param {string} width
     */
    constructor(width) {
        super();
        this.width = width;
    }

    _export() {
        return {
            outlineStyle: "solid",
            outlineWidth: this.width,
        };
    }
}

/** @description Set Outline style. */
class OutlineStyle extends QuadSide {
    /**
     * @overload
     * @param {BorderStyleType} size
     */
    /**
     * @overload
     * @param {BorderStyleType} vertical
     * @param {BorderStyleType} horizontal
     */
    /**
     * @overload
     * @param {BorderStyleType} top
     * @param {BorderStyleType} horizontal
     * @param {BorderStyleType} bottom
     */
    /**
     * @overload
     * @param {BorderStyleType} top
     * @param {BorderStyleType} right
     * @param {BorderStyleType} bottom
     * @param {BorderStyleType} left
     */
    /**
     * @param {BorderStyleType} top
     * @param {BorderStyleType} [right]
     * @param {BorderStyleType} [bottom]
     * @param {BorderStyleType} [left]
     */
    constructor(top, right, bottom, left) {
        super(top, right, bottom, left);
    }

    _export() {
        return {
            outlineStyle: this._getSides(),
        };
    }
}

/**
 * @description Set Outline offset (placement of the outline).
 */
class OutlineOffset extends QuadSide {
    _export() {
        return {
            outlineOffset: this._getSides(),
        };
    }
}

/**
 * @description Set Outline radius (corner's roundness of an element).
 */
class OutlineRadius extends QuadSide {
    _export() {
        return {
            outlineRadius: this._getSides(),
        };
    }
}

/**
 * @description Set content overflow state.
 */
class Overflow extends CssProperty {
    /** @param {...OverflowState} param */
    constructor(...param) {
        super();
        this.param = param;
    }

    _export() {
        return {
            overflow: this.param.join(" "),
        };
    }
}

/**
 * @description Set shadow property for the element.
 */
class ShadowDrop extends CssProperty {
    /**
     * @overload
     * @param {string|number} offsetX
     * @param {string|number} offsetY
     * @param {string} color
     */
    /**
     * @overload
     * @param {string|number} offsetX
     * @param {string|number} offsetY
     * @param {string|number} blurRadius
     * @param {string} color
     */
    /**
     * @overload
     * @param {string|number} offsetX
     * @param {string|number} offsetY
     * @param {string|number} blurRadius
     * @param {string|number} spreadRadius
     * @param {string} color
     */
    /**
     * @param {...string} params
     */
    constructor(...params) {
        super();
        this.params = params;
        this.isInset = false;
    }

    /**
     * Set the shadow drop to be inside the element.
     */
    inset() {
        this.isInset = true;
        return this;
    }

    _export() {
        if (this.isInset) {
            this.params.unshift("inset");
        }
        return {
            boxShadow: this.params.join(" "),
        };
    }
}

/**
 * @description Controls the CSS `font-family` property.
 */
class FontFamily extends CssProperty {
    /**
     * @constructor
     * @param {...string} values - The value for the font-family property (e.g., "Arial, sans-serif").
     */
    constructor(...values) {
        super();
        this.value = values.join(" ");
    }

    /**
     * @method _export
     * @description Exports the `fontFamily` CSS property.
     * @returns {Object} An object containing the `fontFamily` property in camelCase.
     */
    _export() {
        return {
            fontFamily: this.value,
        };
    }
}

/**
 * @description Controls the CSS `font-size` property.
 */
class FontSize extends CssProperty {
    /**
     * @constructor
     * @param {...string} values - The value for the font-size property (e.g., "16px", "1.2em").
     */
    constructor(...values) {
        super();
        this.value = values.join(" ");
    }

    /**
     * @method _export
     * @description Exports the `fontSize` CSS property.
     * @returns {Object} An object containing the `fontSize` property in camelCase.
     */
    _export() {
        return {
            fontSize: this.value,
        };
    }
}

/**
 * @description Controls the CSS `font-weight` property.
 */
class FontWeight extends CssProperty {
    /**
     * @constructor
     * @param {...string} values - The value for the font-weight property (e.g., "bold", 700).
     */
    constructor(...values) {
        super();
        this.value = values.join(" ");
    }

    /**
     * @method _export
     * @description Exports the `fontWeight` CSS property.
     * @returns {Object} An object containing the `fontWeight` property in camelCase.
     */
    _export() {
        return {
            fontWeight: this.value,
        };
    }
}

/**
 * @description Controls the CSS `font-style` property.
 */
class FontStyle extends CssProperty {
    /**
     * @constructor
     * @param {...string} values - The value for the font-style property (e.g., "italic", "normal").
     */
    constructor(...values) {
        super();
        this.value = values.join(" ");
    }

    /**
     * @method _export
     * @description Exports the `fontStyle` CSS property.
     * @returns {Object} An object containing the `fontStyle` property in camelCase.
     */
    _export() {
        return {
            fontStyle: this.value,
        };
    }
}

/**
 * @description Controls the CSS `font-variant` property.
 */
class FontVariant extends CssProperty {
    /**
     * @constructor
     * @param {...string} values - The value for the font-variant property (e.g., "small-caps", "normal").
     */
    constructor(...values) {
        super();
        this.value = values.join(" ");
    }

    /**
     * @method _export
     * @description Exports the `fontVariant` CSS property.
     * @returns {Object} An object containing the `fontVariant` property in camelCase.
     */
    _export() {
        return {
            fontVariant: this.value,
        };
    }
}

/**
 * @description Controls the CSS `font-stretch` property.
 */
class FontStretch extends CssProperty {
    /**
     * @constructor
     * @param {...string} values - The value for the font-stretch property (e.g., "expanded", "condensed", "normal").
     */
    constructor(...values) {
        super();
        this.value = values.join(" ");
    }

    /**
     * @method _export
     * @description Exports the `fontStretch` CSS property.
     * @returns {Object} An object containing the `fontStretch` property in camelCase.
     */
    _export() {
        return {
            fontStretch: this.value,
        };
    }
}

/**
 * @description Set properties for this pseudoclass.
 */
class ConditionalProperty extends CssProperty {
    /**
     * @param {string} name
     */
    constructor(name) {
        super();
        this.name = name;
        /** @type {CssProperty[]} */
        this.properties = [];
    }

    /**
     * @param  {...CssProperty} properties
     */
    define(...properties) {
        this.properties = properties;
        return this;
    }

    _export() {
        const properties = {};
        for (const property of this.properties) {
            Object.assign(properties, property._export());
        }
        return {
            [this.name]: properties,
        };
    }
}

/**
 * @description Define pseudoclass (HTML element state).
 */
class Pseudoclass extends ConditionalProperty {
    /**
     * @param {string} name
     */
    constructor(name) {
        super(name);
    }
}

/**
 * @description Define media query (conditions) for this to trigger.
 */
class MediaQuery extends ConditionalProperty {
    /**
     * @param {string} query
     */
    constructor(query) {
        super(query);
    }
}

class DandelionCssBuilder {
    /**
     * @param {string} [name]
     */
    constructor(name) {
        this.name = name || "";
        this.hasName = true;
        /** @type {CssProperty[]} */
        this.addedProperties = [];
    }

    /**
     * Make this style nameless.
     */
    noName() {
        this.hasName = false;
        return this;
    }

    /**
     * Set properties for this named class.
     * @param  {...CssProperty} properties
     */
    properties(...properties) {
        this.addedProperties = properties;
        return this.create();
    }

    create() {
        const properties = this.addedProperties;
        /** @type {MediaQuery[]} */
        const mediaQueries = [];
        /** @type {Pseudoclass[]} */
        const pseudoClasses = [];
        let i = 0;
        while (i < properties.length) {
            const property = properties[i];
            if (property instanceof MediaQuery) {
                properties.splice(i, 1);
                mediaQueries.push(property);
            } else if (property instanceof Pseudoclass) {
                properties.splice(i, 1);
                pseudoClasses.push(property);
            } else {
                i++;
            }
        }

        const processedProperties = {};
        for (const property of properties) {
            Object.assign(processedProperties, property._export());
        }

        const processedMediaQueries = {};
        for (const mediaQuery of mediaQueries) {
            Object.assign(processedMediaQueries, mediaQuery._export());
        }

        const processedPseudoclasses = {};
        for (const pseudoClass of pseudoClasses) {
            Object.assign(processedPseudoclasses, pseudoClass._export());
        }

        cssManager
            .define(processedProperties)
            .addMediaQueries(processedMediaQueries)
            .addPseudoClasses(processedPseudoclasses);

        if (this.hasName) {
            return cssManager.createWithName(this.name);
        } else {
            return cssManager.createWithoutName();
        }
    }
}

// -------------------- START Functions --------------------

/**
 * Generate colours for pressable colour states
 * @param {object|string} source
 */
function MixColors(source) {
    if (typeof source === "string") {
        source = hexToRgbaObject(source);
    }

    const { normal, hover, pressed } = getButtonStateColors(source);
    const hoverStr = rgb(hover.bg.r, hover.bg.g, hover.bg.b);
    const hoverBorderStr = rgb(hover.border.r, hover.border.g, hover.border.b);
    const pressedStr = rgb(pressed.bg.r, pressed.bg.g, pressed.bg.b);
    const pressedBorderStr = rgb(
        pressed.border.r,
        pressed.border.g,
        pressed.border.b,
    );

    return {
        normal: rgb(normal.bg.r, normal.bg.g, normal.bg.b),
        normalBorder: rgb(normal.border.r, normal.border.g, normal.border.b),
        hover: hoverStr,
        hoverBorder: hoverBorderStr,
        pressed: pressedStr,
        pressedBorder: pressedBorderStr,
        darker: pressed,
        darker2: pressedBorderStr,
    };
}

/**
 * @param {{
 * normal: string,
 * normalBorder: string,
 * hover: string,
 * hoverBorder: string,
 * pressed: string,
 * pressedBorder: string
 * }} param0
 * @returns
 */
function _ButtonColorStyle({
    normal,
    normalBorder,
    hover,
    hoverBorder,
    pressed,
    pressedBorder,
}) {
    return Style(
        new BackgroundColor(normal),
        new BorderColor(normalBorder),
        new Pseudoclass("hover").define(
            new BackgroundColor(hover),
            new BorderColor(hoverBorder),
        ),
        new Pseudoclass("active").define(
            new BackgroundColor(pressed),
            new BackgroundColor(pressedBorder),
        ),
    );
}

/**
 * Generate a colour style for
 * @param {object|string} source
 */
function ButtonColorStyle(source) {
    return _ButtonColorStyle(MixColors(source));
}

/**
 * Generate mixed colours and CSS style for buttons.
 * @param {object|string} source
 */
function GetMixedColorsAndStyle(source) {
    if (typeof source === "string") {
        source = hexToRgbaObject(source);
    }
    const col = MixColors(source);
    const {
        normal,
        normalBorder,
        hover,
        hoverBorder,
        pressed,
        pressedBorder,
    } = col;
    return {
        col: col,
        style: Style(
            new BackgroundColor(normal),
            new BorderColor(normalBorder),
            new Pseudoclass("hover").define(
                new BackgroundColor(hover),
                new BorderColor(hoverBorder),
            ),
            new Pseudoclass("active").define(
                new BackgroundColor(pressed),
                new BackgroundColor(pressedBorder),
            ),
        ),
    };
}

// -------------------- END Functions --------------------

// -------------------- START Macros --------------------

//@ts-check
/**
 * Sets a conic gradient as the background image.
 * @overload
 * @param {string} colorStop1 The first color stop, optionally with a position (e.g., 'red', 'blue 20%').
 * @param {string} colorStop2 The second color stop, optionally with a position.
 * @param {...string} additionalColorStops Additional color stops.
 */
/**
 * Sets a conic gradient as the background image.
 * @overload
 * @param {string} fromAngle Optional: The starting angle of the gradient (e.g., 'from 90deg').
 * @param {string} atPosition Optional: The position of the gradient's center (e.g., 'at 50% 50%').
 * @param {string} colorStop1 The first color stop, optionally with a position.
 * @param {string} colorStop2 The second color stop, optionally with a position.
 * @param {...string} additionalColorStops Additional color stops.
 */
/**
 * @param {...string} args
 */
function conicGradient(...args) {
    return `conic-gradient(${args.join(", ")})`;
}

/**
 * Creates a radial gradient image.
 * @overload
 * @param {string} shapeAndSize Optional: The shape and size of the gradient (e.g., 'circle', 'ellipse closest-corner').
 * @param {string} position Optional: The position of the gradient's center (e.g., 'at 50% 50%').
 * @param {string} colorStop1 The first color stop, optionally with a position (e.g., 'red', 'blue 20%').
 * @param {string} colorStop2 The second color stop, optionally with a position.
 * @param {...string} additionalColorStops Additional color stops.
 */
/**
 * @param {...string} args
 */
function radialGradient(...args) {
    return `radial-gradient(${args.join(", ")})`;
}

/**
 * Creates a repeating linear gradient image.
 * @overload
 * @param {string} direction Optional: The direction of the gradient (e.g., 'to right', '45deg').
 * @param {string} colorStop1 The first color stop, optionally with a position (e.g., 'red', 'blue 20%').
 * @param {string} colorStop2 The second color stop, optionally with a position.
 * @param {...string} additionalColorStops Additional color stops.
 */
/**
 * @param {...string} args
 */
function repeatingLinearGradient(...args) {
    return `repeating-linear-gradient(${args.join(", ")})`;
}

/**
 * Creates a repeating radial gradient image.
 * @overload
 * @param {string} shapeAndSize Optional: The shape and size of the gradient (e.g., 'circle', 'ellipse closest-corner').
 * @param {string} position Optional: The position of the gradient's center (e.g., 'at 50% 50%').
 * @param {string} colorStop1 The first color stop, optionally with a position (e.g., 'red', 'blue 20%').
 * @param {string} colorStop2 The second color stop, optionally with a position.
 * @param {...string} additionalColorStops Additional color stops.
 */
/**
 * @param {...string} args
 */
function repeatingRadialGradient(...args) {
    return `repeating-radial-gradient(${args.join(", ")})`;
}

/**
 * Creates a repeating conic gradient image.
 * @overload
 * @param {string} fromAngle Optional: The starting angle of the gradient (e.g., 'from 90deg').
 * @param {string} atPosition Optional: The position of the gradient's center (e.g., 'at 50% 50%').
 * @param {string} colorStop1 The first color stop, optionally with a position (e.g., 'red', 'blue 20%').
 * @param {string} colorStop2 The second color stop, optionally with a position.
 * @param {...string} additionalColorStops Additional color stops.
 */
/**
 * @param {...string} args
 */
function repeatingConicGradient(...args) {
    return `repeating-conic-gradient(${args.join(", ")})`;
}

/**
 * Inserts an image with a filter.
 * @overload
 * @param {string} url The URL of the image.
 * @param {string} filter The filter function (e.g., 'blur(5px)', 'grayscale(1)').
 */
/**
 * @param {...string} args
 */
function image(...args) {
    return `image(${args.join(", ")})`;
}

/**
 * Creates a URL for an image.
 * @param {string} url The URL of the image.
 */
function url(url) {
    return `url('${url}')`;
}

/**
 * Applies a blur effect to an image.
 * @param {string|number} radius The radius of the blur.
 */
function blur(radius) {
    return `blur(${radius})`;
}

/**
 * Adjusts the brightness of an image.
 * @param {string} amount The amount of brightness (e.g., '0' for black, '1' for original, '2' for twice as bright).
 */
function brightness(amount) {
    return `brightness(${amount})`;
}

/**
 * Adjusts the contrast of an image.
 * @param {string|number} amount The amount of contrast (e.g., '0' for no contrast, '1' for original, '2' for twice as contrast).
 */
function contrast(amount) {
    return `contrast(${amount})`;
}

/**
 * Applies a drop shadow to an image.
 * @param {string|number} offsetX The horizontal offset of the shadow.
 * @param {string|number} offsetY The vertical offset of the shadow.
 * @param {string|number} blurRadius Optional: The blur radius of the shadow.
 * @param {string|number} spreadRadius Optional: The spread radius of the shadow.
 * @param {string} color Optional: The color of the shadow.
 */
function dropShadow(
    offsetX,
    offsetY,
    blurRadius = "",
    spreadRadius = "",
    color = "",
) {
    const args = [offsetX, offsetY, blurRadius, spreadRadius, color].filter(
        Boolean,
    );
    return `drop-shadow(${args.join(" ")})`;
}

/**
 * Converts an image to grayscale.
 * @param {string|number} amount The amount of grayscale (e.g., '0' for original, '1' for full grayscale).
 */
function grayscale(amount) {
    return `grayscale(${amount})`;
}

/**
 * Rotates the hue of an image.
 * @param {string|number} angle The angle of hue rotation (e.g., '90deg').
 */
function hueRotate(angle) {
    return `hue-rotate(${angle})`;
}

/**
 * Inverts the colors of an image.
 * @param {string|number} amount The amount of inversion (e.g., '0' for original, '1' for full inversion).
 */
function invert(amount) {
    return `invert(${amount})`;
}

/**
 * Adds transparency to an image.
 * @param {string|number} amount The amount of opacity (e.g., '0' for fully transparent, '1' for fully opaque).
 */
function opacity(amount) {
    return `opacity(${amount})`;
}

/**
 * Applies a sepia effect to an image.
 * @param {string|number} amount The amount of sepia (e.g., '0' for original, '1' for full sepia).
 */
function sepia(amount) {
    return `sepia(${amount})`;
}

/**
 * Scales an image in 3D space.
 * @param {string|number} sx The scale factor along the x-axis.
 * @param {string|number} sy Optional: The scale factor along the y-axis. If omitted, sx is used for both.
 */
function scale3d(sx, sy = "") {
    const args = [sx, sy].filter(Boolean);
    return `scale3d(${args.join(", ")})`;
}

/**
 * Scales an image along the x-axis.
 * @param {string|number} sx The scale factor along the x-axis.
 */
function scaleX(sx) {
    return `scaleX(${sx})`;
}

/**
 * Scales an image along the y-axis.
 * @param {string|number} sy The scale factor along the y-axis.
 */
function scaleY(sy) {
    return `scaleY(${sy})`;
}

/**
 * Scales an image along the z-axis.
 * @param {string|number} sz The scale factor along the z-axis.
 */
function scaleZ(sz) {
    return `scaleZ(${sz})`;
}

/**
 * Rotates an element in 3D space.
 * @param {string|number} x The x-component of the rotation vector.
 * @param {string|number} y The y-component of the rotation vector.
 * @param {string|number} z The z-component of the rotation vector.
 * @param {string|number} angle The angle of rotation.
 */
function rotate3d(x, y, z, angle) {
    return `rotate3d(${x}, ${y}, ${z}, ${angle})`;
}

/**
 * Rotates an element around the x-axis.
 * @param {string|number} angle The angle of rotation.
 */
function rotateX(angle) {
    return `rotateX(${angle})`;
}

/**
 * Rotates an element around the y-axis.
 * @param {string|number} angle The angle of rotation.
 */
function rotateY(angle) {
    return `rotateY(${angle})`;
}

/**
 * Rotates an element around the z-axis.
 * @param {string|number} angle The angle of rotation.
 */
function rotateZ(angle) {
    return `rotateZ(${angle})`;
}

/**
 * Rotates an element.
 * @param {string|number} angle The angle of rotation.
 */
function rotate(angle) {
    return `rotate(${angle})`;
}

/**
 * Translates an element in 3D space.
 * @param {string|number} tx The translation along the x-axis.
 * @param {string|number} ty Optional: The translation along the y-axis.
 * @param {string|number} tz Optional: The translation along the z-axis.
 */
function translate3d(tx, ty = "", tz = "") {
    const args = [tx, ty, tz].filter(Boolean);
    return `translate3d(${args.join(", ")})`;
}

/**
 * Translates an element along the x-axis.
 * @param {string|number} tx The translation along the x-axis.
 */
function translateX(tx) {
    return `translateX(${tx})`;
}

/**
 * Translates an element along the y-axis.
 * @param {string|number} ty The translation along the y-axis.
 */
function translateY(ty) {
    return `translateY(${ty})`;
}

/**
 * Translates an element along the z-axis.
 * @param {string|number} tz The translation along the z-axis.
 */
function translateZ(tz) {
    return `translateZ(${tz})`;
}

/**
 * Translates an element.
 * @param {string|number} tx The translation along the x-axis.
 * @param {string|number} ty Optional: The translation along the y-axis.
 */
function translate(tx, ty = "") {
    const args = [tx, ty].filter(Boolean);
    return `translate(${args.join(", ")})`;
}

/**
 * Skews an element along the x-axis.
 * @param {string|number} angle The skew angle along the x-axis.
 */
function skewX(angle) {
    return `skewX(${angle})`;
}

/**
 * Skews an element along the y-axis.
 * @param {string|number} angle The skew angle along the y-axis.
 */
function skewY(angle) {
    return `skewY(${angle})`;
}

/**
 * Skews an element.
 * @param {string|number} angleX The skew angle along the x-axis.
 * @param {string|number} angleY Optional: The skew angle along the y-axis.
 */
function skew(angleX, angleY = "") {
    const args = [angleX, angleY].filter(Boolean);
    return `skew(${args.join(", ")})`;
}

/**
 * Defines a 2D transformation matrix.
 * @param {string|number} a The a parameter.
 * @param {string|number} b The b parameter.
 * @param {string|number} c The c parameter.
 * @param {string|number} d The d parameter.
 * @param {string|number} e The e parameter.
 * @param {string|number} f The f parameter.
 */
function matrix(a, b, c, d, e, f) {
    return `matrix(${a}, ${b}, ${c}, ${d}, ${e}, ${f})`;
}

/**
 * Defines a 3D transformation matrix.
 * @param {string|number} a1 The first row, first column value.
 * @param {string|number} b1 The first row, second column value.
 * @param {string|number} c1 The first row, third column value.
 * @param {string|number} d1 The first row, fourth column value.
 * @param {string|number} a2 The second row, first column value.
 * @param {string|number} b2 The second row, second column value.
 * @param {string|number} c2 The second row, third column value.
 * @param {string|number} d2 The second row, fourth column value.
 * @param {string|number} a3 The third row, first column value.
 * @param {string|number} b3 The third row, second column value.
 * @param {string|number} c3 The third row, third column value.
 * @param {string|number} d3 The third row, fourth column value.
 * @param {string|number} a4 The fourth row, first column value.
 * @param {string|number} b4 The fourth row, second column value.
 * @param {string|number} c4 The fourth row, third column value.
 * @param {string|number} d4 The fourth row, fourth column value.
 */
function matrix3d(
    a1,
    b1,
    c1,
    d1,
    a2,
    b2,
    c2,
    d2,
    a3,
    b3,
    c3,
    d3,
    a4,
    b4,
    c4,
    d4,
) {
    return `matrix3d(${a1}, ${b1}, ${c1}, ${d1}, ${a2}, ${b2}, ${c2}, ${d2}, ${a3}, ${b3}, ${c3}, ${d3}, ${a4}, ${b4}, ${c4}, ${d4})`;
}

/**
 * Sets the perspective for 3D transformed elements.
 * @param {string|number} length The distance from the viewer to the z-plane.
 */
function perspective(length) {
    return `perspective(${length})`;
}

/**
 * Clips an element to a circle shape.
 * @overload
 * @param {string|number} radius The radius of the circle.
 * @param {string|number} atPosition Optional: The position of the center of the circle (e.g., 'at 50% 50%').
 */
/**
 * @param {...string} args
 */
function circle(...args) {
    return `circle(${args.join(" ")})`;
}

/**
 * Clips an element to an ellipse shape.
 * @overload
 * @param {string|number} radiusX The horizontal radius of the ellipse.
 * @param {string|number} radiusY The vertical radius of the ellipse.
 * @param {string|number} atPosition Optional: The position of the center of the ellipse (e.g., 'at 50% 50%').
 */
/**
 * @param {...string} args
 */
function ellipse(...args) {
    return `ellipse(${args.join(" ")})`;
}

/**
 * Clips an element to an inset rectangle shape.
 * @param {string|number} top The top offset.
 * @param {string|number} right The right offset.
 * @param {string|number} bottom The bottom offset.
 * @param {string|number} left The left offset.
 * @param {string|number} borderRadius Optional: The border-radius for the corners.
 */
function inset(top, right, bottom, left, borderRadius = "") {
    const args = [top, right, bottom, left].filter(Boolean);
    let result = `inset(${args.join(" ")})`;
    if (borderRadius) {
        result += ` round ${borderRadius}`;
    }
    return result;
}

/**
 * Clips an element to a polygon shape.
 * @param {...string} points A series of x y coordinate pairs defining the polygon's vertices (e.g., '0% 0%', '100% 0%', '100% 100%').
 */
function polygon(...points) {
    return `polygon(${points.join(", ")})`;
}

/**
 * Clips an element to a path.
 * @param {string|number} path The SVG path data.
 */
function path(path) {
    return `path(${path})`;
}

/**
 * Defines a rectangle for a shape.
 * @param {string|number} x The x-coordinate of the top-left corner.
 * @param {string|number} y The y-coordinate of the top-left corner.
 * @param {string|number} width The width of the rectangle.
 * @param {string|number} height The height of the rectangle.
 * @param {string|number} rx Optional: The x-axis radius of the ellipse for rounding corners.
 * @param {string|number} ry Optional: The y-axis radius of the ellipse for rounding corners.
 */
function rect(x, y, width, height, rx = "", ry = "") {
    const args = [x, y, width, height, rx, ry].filter(Boolean);
    return `rect(${args.join(", ")})`;
}

/**
 * Defines a border-box for a shape.
 */
function borderBox() {
    return `border-box`;
}

/**
 * Defines a padding-box for a shape.
 */
function paddingBox() {
    return `padding-box`;
}

/**
 * Defines a content-box for a shape.
 */
function contentBox() {
    return `content-box`;
}

/**
 * Defines a margin-box for a shape.
 */
function marginBox() {
    return `margin-box`;
}

/**
 * Defines a fill-box for a shape.
 */
function fillBox() {
    return `fill-box`;
}

/**
 * Defines a stroke-box for a shape.
 */
function strokeBox() {
    return `stroke-box`;
}

/**
 * Defines a view-box for a shape.
 */
function viewBox() {
    return `view-box`;
}

/**
 * Sets a step timing function.
 * @param {number} numberOfSteps The number of equidistant animation segments.
 * @param {string|number} direction Optional: 'start' or 'end' (default 'end').
 */
function steps(numberOfSteps, direction = "") {
    const args = [numberOfSteps, direction].filter(Boolean);
    return `steps(${args.join(", ")})`;
}

/**
 * Sets a cubic-bezier timing function.
 * @param {number} p1 The x-coordinate of the first control point.
 * @param {number} p2 The y-coordinate of the first control point.
 * @param {number} p3 The x-coordinate of the second control point.
 * @param {number} p4 The y-coordinate of the second control point.
 */
function cubicBezier(p1, p2, p3, p4) {
    return `cubic-bezier(${p1}, ${p2}, ${p3}, ${p4})`;
}

/**
 * Sets a frames timing function.
 * @param {number} numberOfFrames The number of frames in the animation.
 */
function frames(numberOfFrames) {
    return `frames(${numberOfFrames})`;
}

/**
 * Creates a counter.
 * @param {string} name The name of the counter.
 * @param {string|number} value Optional: The initial value of the counter.
 */
function counter(name, value = "") {
    const args = [name, value].filter(Boolean);
    return `counter(${args.join(", ")})`;
}

/**
 * Creates counters.
 * @param {string} name The name of the counter.
 * @param {string|number} value Optional: The initial value of the counter.
 */
function counters(name, value = "") {
    const args = [name, value].filter(Boolean);
    return `counters(${args.join(", ")})`;
}

/**
 * Defines a 'calc()' CSS function.
 * @param {string} expression The mathematical expression to be calculated.
 */
function calc(expression) {
    return `calc(${expression})`;
}

/**
 * Defines a 'min()' CSS function.
 * @param {...string} values A comma-separated list of values.
 */
function min(...values) {
    return `min(${values.join(", ")})`;
}

/**
 * Defines a 'max()' CSS function.
 * @param {...string} values A comma-separated list of values.
 */
function max(...values) {
    return `max(${values.join(", ")})`;
}

/**
 * Defines a 'clamp()' CSS function.
 * @param {string|number} min The minimum value.
 * @param {string|number} val The preferred value.
 * @param {string|number} max The maximum value.
 */
function clamp(min, val, max) {
    return `clamp(${min}, ${val}, ${max})`;
}

/**
 * Defines a 'var()' CSS function.
 * @param {string} customPropertyName The name of the custom property (e.g., '--my-color').
 * @param {string} fallbackValue Optional: A fallback value if the custom property is not defined.
 */
function cssVar(customPropertyName, fallbackValue = "") {
    const args = [customPropertyName, fallbackValue].filter(Boolean);
    return `var(${args.join(", ")})`;
}

/**
 * Represents the current value of a CSS variable within a `calc()` expression.
 * @param {string} customPropertyName The name of the custom property (e.g., '--my-length').
 */
function varInCalc(customPropertyName) {
    return `var(${customPropertyName})`;
}

/**
 * Defines a 'attr()' CSS function.
 * @param {string} attributeName The name of the HTML attribute.
 * @param {string} typeOrUnit Optional: The type or unit of the attribute value (e.g., 'px', 'em', 'string').
 * @param {string} fallback Optional: A fallback value if the attribute is not found.
 */
function attr(attributeName, typeOrUnit = "", fallback = "") {
    const args = [attributeName, typeOrUnit, fallback].filter(Boolean);
    return `attr(${args.join(" ")})`;
}

/**
 * Defines a 'rgb()' color.
 * @param {number} r The red component (0-255).
 * @param {number} g The green component (0-255).
 * @param {number} b The blue component (0-255).
 */
function rgb(r, g, b) {
    return `rgb(${r}, ${g}, ${b})`;
}

/**
 * Defines a 'rgba()' color.
 * @param {number} r The red component (0-255).
 * @param {number} g The green component (0-255).
 * @param {number} b The blue component (0-255).
 * @param {number} a The alpha (opacity) component (0-1).
 */
function rgba(r, g, b, a) {
    return `rgba(${r}, ${g}, ${b}, ${a})`;
}

/**
 * Defines an 'hsl()' color.
 * @param {string|number} h The hue (0-360deg, or a unitless number).
 * @param {string|number} s The saturation (e.g., '100%', '50%').
 * @param {string|number} l The lightness (e.g., '100%', '50%').
 */
function hsl(h, s, l) {
    return `hsl(${h}, ${s}, ${l})`;
}

/**
 * Defines an 'hsla()' color.
 * @param {string|number} h The hue (0-360deg, or a unitless number).
 * @param {string|number} s The saturation (e.g., '100%', '50%').
 * @param {string|number} l The lightness (e.g., '100%', '50%').
 * @param {number} a The alpha (opacity) component (0-1).
 */
function hsla(h, s, l, a) {
    return `hsla(${h}, ${s}, ${l}, ${a})`;
}

/**
 * Defines a 'lab()' color.
 * @param {string|number} l The lightness component (0-100%).
 * @param {string|number} a The a-axis component (-128 to 127).
 * @param {string|number} b The b-axis component (-128 to 127).
 * @param {string|number} alpha Optional: The alpha (opacity) component (0-1).
 */
function lab(l, a, b, alpha = "") {
    const args = [l, a, b, alpha].filter(Boolean);
    return `lab(${args.join(" ")})`;
}

/**
 * Defines an 'lch()' color.
 * @param {string|number} l The lightness component (0-100%).
 * @param {string|number} c The chroma component (0 to approx. 150).
 * @param {string|number} h The hue component (0-360deg).
 * @param {string|number} alpha Optional: The alpha (opacity) component (0-1).
 */
function lch(l, c, h, alpha = "") {
    const args = [l, c, h, alpha].filter(Boolean);
    return `lch(${args.join(" ")})`;
}

/**
 * Defines an 'oklab()' color.
 * @param {string|number} l The lightness component (0-1).
 * @param {string|number} a The a-axis component (-0.5 to 0.5).
 * @param {string|number} b The b-axis component (-0.5 to 0.5).
 * @param {string|number} alpha Optional: The alpha (opacity) component (0-1).
 */
function oklab(l, a, b, alpha = "") {
    const args = [l, a, b, alpha].filter(Boolean);
    return `oklab(${args.join(" ")})`;
}

/**
 * Defines an 'oklch()' color.
 * @param {string|number} l The lightness component (0-1).
 * @param {string|number} c The chroma component (0 to approx. 0.4).
 * @param {string|number} h The hue component (0-360deg).
 * @param {string|number} alpha Optional: The alpha (opacity) component (0-1).
 */
function oklch(l, c, h, alpha = "") {
    const args = [l, c, h, alpha].filter(Boolean);
    return `oklch(${args.join(" ")})`;
}

/**
 * Defines a 'color()' CSS function.
 * @param {string} colorSpace The color space (e.g., 'srgb', 'display-p3', 'rec2020', 'a98-rgb', 'prophoto-rgb', 'xyz', 'xyz-d50', 'xyz-d65').
 * @param {...string} components The color components, followed by an optional alpha.
 */
function color(colorSpace, ...components) {
    return `color(${colorSpace} ${components.join(" ")})`;
}

/**
 * Defines a 'url()' for cursor.
 * @param {string} url The URL of the image.
 * @param {number} x The x-coordinate of the hotspot.
 * @param {number} y The y-coordinate of the hotspot.
 */
function cursorUrl(url, x, y) {
    return `url('${url}') ${x} ${y}`;
}

/**
 * Defines a 'minmax()' CSS function for grid tracks.
 * @param {string|number} min The minimum size.
 * @param {string|number} max The maximum size.
 */
function minmax(min, max) {
    return `minmax(${min}, ${max})`;
}

/**
 * Defines a 'fit-content()' CSS function.
 * @param {string|number} length The desired length.
 */
function fitContent(length) {
    return `fit-content(${length})`;
}

/**
 * Defines a 'element()' CSS function.
 * @param {string} id The ID of the element.
 */
function element(id) {
    return `element(#${id})`;
}

/**
 * Defines a 'cross-fade()' CSS function.
 * @param {string|number} percentage The percentage of the first image to show.
 * @param {string} image1 The first image URL or gradient.
 * @param {string} image2 The second image URL or gradient.
 */
function crossFade(percentage, image1, image2) {
    return `cross-fade(${percentage}, ${image1}, ${image2})`;
}

/**
 * Defines a 'image-set()' CSS function.
 * @param {...string} args A comma-separated list of image candidates.
 */
function imageSet(...args) {
    return `image-set(${args.join(", ")})`;
}

/**
 * Defines a 'toggle()' CSS function.
 * @param {...string} values A comma-separated list of values to toggle between.
 */
function toggle(...values) {
    return `toggle(${values.join(", ")})`;
}

/**
 * Defines a 'format()' CSS function.
 * @param {string} format The format of the font.
 */
function format(format) {
    return `format('${format}')`;
}

/**
 * Defines a 'font-face()' CSS function for src.
 * @param {string} url The URL of the font file.
 * @param {string} format Optional: The format of the font.
 */
function fontFaceSrc(url, format = "") {
    return `${url} ${format ? `format('${format}')` : ""}`;
}

/**
 * Defines a 'symbols()' CSS function for list-style-image.
 * @param {string} type The type of symbols (e.g., 'cyclic', 'alphabetic', 'numeric').
 * @param {...string} symbols The symbols to use.
 */
function symbols(type, ...symbols) {
    return `symbols(${type} ${symbols.join(" ")})`;
}

/**
 * Defines a 'leader()' CSS function for generated content.
 * @param {string} character The character to use as a leader.
 */
function leader(character) {
    return `leader(${character})`;
}

/**
 * Defines a 'counter-style()' CSS function for list-style.
 * @param {string} name The name of the counter style.
 */
function counterStyle(name) {
    return `counter-style(${name})`;
}

/**
 * Defines a 'line-gradient()' CSS function (deprecated, replaced by linear-gradient).
 * @param {string} angleOrSide The angle or side of the gradient.
 * @param {string} colorStop1 The first color stop.
 * @param {string} colorStop2 The second color stop.
 * @param {...string} additionalColorStops Additional color stops.
 */
function lineGradient(
    angleOrSide,
    colorStop1,
    colorStop2,
    ...additionalColorStops
) {
    const args = [angleOrSide, colorStop1, colorStop2, ...additionalColorStops];
    return `line-gradient(${args.join(", ")})`;
}

/**
 * Calculates the arc cosine of a number.
 * @param {string|number} value The value to calculate the arc cosine of.
 */
function acos(value) {
    return `acos(${value})`;
}

/**
 * Calculates the arc sine of a number.
 * @param {string|number} value The value to calculate the arc sine of.
 */
function asin(value) {
    return `asin(${value})`;
}

/**
 * Calculates the arc tangent of a number.
 * @param {string|number} value The value to calculate the arc tangent of.
 */
function atan(value) {
    return `atan(${value})`;
}

/**
 * Calculates the arc tangent of the quotient of two numbers.
 * @param {string|number} y The y-coordinate.
 * @param {string|number} x The x-coordinate.
 */
function atan2(y, x) {
    return `atan2(${y}, ${x})`;
}

/**
 * Mixes two colors together in a specified colorspace.
 * @param {string} colorSpace The color space to mix in (e.g., 'srgb', 'hsl', 'lch').
 * @param {string} color1 The first color.
 * @param {string|number} percentage1 The percentage of the first color.
 * @param {string} color2 The second color.
 * @param {string|number} percentage2 Optional: The percentage of the second color.
 */
function colorMix(
    colorSpace,
    color1,
    percentage1,
    color2,
    percentage2 = "",
) {
    const args = [colorSpace, color1, percentage1, color2, percentage2].filter(
        Boolean,
    );
    return `color-mix(${args.join(" ")})`;
}

/**
 * Calculates the cosine of an angle.
 * @param {string|number} angle The angle to calculate the cosine of.
 */
function cos(angle) {
    return `cos(${angle})`;
}

/**
 * Calculates E to the power of a number.
 * @param {string|number} value The exponent.
 */
function exp(value) {
    return `exp(${value})`;
}

/**
 * Defines an 'hwb()' color.
 * @param {string|number} h The hue (0-360deg, or a unitless number).
 * @param {string|number} w The whiteness (0-100%).
 * @param {string|number} b The blackness (0-100%).
 * @param {string|number} a Optional: The alpha (opacity) component (0-1).
 */
function hwb(h, w, b, a = "") {
    const args = [h, w, b, a].filter(Boolean);
    return `hwb(${args.join(" ")})`;
}

/**
 * Calculates the square root of the sum of the squares of its arguments.
 * @param {...string} values A comma-separated list of numbers.
 */
function hypot(...values) {
    return `hypot(${values.join(", ")})`;
}

/**
 * Selects a color based on the user's preferred color scheme.
 * @param {string} lightColor The color to use in light mode.
 * @param {string} darkColor The color to use in dark mode.
 */
function lightDark(lightColor, darkColor) {
    return `light-dark(${lightColor}, ${darkColor})`;
}

/**
 * Calculates the natural logarithm of a number.
 * @param {string|number} value The value to calculate the logarithm of.
 */
function log(value) {
    return `log(${value})`;
}

/**
 * Calculates the remainder of a division.
 * @param {string|number} dividend The number to be divided.
 * @param {string|number} divisor The number to divide by.
 */
function mod(dividend, divisor) {
    return `mod(${dividend}, ${divisor})`;
}

/**
 * Calculates a number raised to the power of another.
 * @param {string|number} base The base number.
 * @param {string|number} exponent The exponent.
 */
function pow(base, exponent) {
    return `pow(${base}, ${exponent})`;
}

/**
 * Defines a ray for `offset-path`.
 * @overload
 * @param {string|number} angle The angle of the ray.
 * @param {string|number} size Optional: The size of the ray.
 * @param {string|number} contain Optional: 'contain' keyword.
 */
/**
 * @param {...string} args
 */
function ray(...args) {
    return `ray(${args.join(" ")})`;
}

/**
 * Calculates the remainder of a division, similar to modulo but handles negative numbers differently.
 * @param {string|number} dividend The number to be divided.
 * @param {string|number} divisor The number to divide by.
 */
function rem(dividend, divisor) {
    return `rem(${dividend}, ${divisor})`;
}

/**
 * Increases the saturation of an image.
 * @param {string|number} amount The amount of saturation (e.g., '0' for grayscale, '1' for original, '2' for double saturation).
 */
function saturate(amount) {
    return `saturate(${amount})`;
}

/**
 * Scales an element.
 * @param {string|number} sx The scale factor along the x-axis.
 * @param {string|number} sy Optional: The scale factor along the y-axis. If omitted, sx is used for both.
 */
function scale(sx, sy = "") {
    const args = [sx, sy].filter(Boolean);
    return `scale(${args.join(", ")})`;
}

/**
 * Calculates the square root of a number.
 * @param {string|number} value The value to calculate the square root of.
 */
function sqrt(value) {
    return `sqrt(${value})`;
}

/**
 * Calculates the tangent of an angle.
 * @param {string|number} angle The angle to calculate the tangent of.
 */
function tan(angle) {
    return `tan(${angle})`;
}

/**
 * Creates a linear gradient image.
 * @overload
 * @param {string} direction Optional: The direction of the gradient (e.g., 'to right', '45deg').
 * @param {string} colorStop1 The first color stop, optionally with a position (e.g., 'red', 'blue 20%').
 * @param {string} colorStop2 The second color stop, optionally with a position.
 * @param {...string} additionalColorStops Additional color stops.
 */
/**
 * @param {...string} args
 */
function linearGradient(...args) {
    return `linear-gradient(${args.join(", ")})`;
}

/**
 * Defines a 'repeat()' CSS function for grid tracks.
 * @overload
 * @param {string} count The number of repetitions or 'auto-fill' / 'auto-fit'.
 * @param {string} trackList A list of track sizes.
 */
/**
 * @param {...string} args
 */
function repeat(...args) {
    return `repeat(${args.join(", ")})`;
}

/**
 * Rounds a number to the nearest integer, or to a specified increment.
 * @overload
 * @param {string} roundingStrategy Optional: 'nearest', 'up', 'down', 'to-zero'.
 * @param {string|number} value The value to round.
 */
/**
 * @overload
 * @param {string} roundingStrategy Optional: 'nearest', 'up', 'down', 'to-zero'.
 * @param {string|number} increment The increment to round to.
 * @param {string|number} value The value to round.
 */
/**
 * @param {...string} args
 */
function round(...args) {
    return `round(${args.join(" ")})`;
}

// -------------------- END Macros --------------------

/**
 * Declare a new CSS style
 * @param  {...CssProperty} properties
 * @returns {string} Class name for this string
 */
function Style(...properties) {
    return new DandelionCssBuilder().properties(...properties);
}

/**
 * Create a named CSS style.
 * @param {string} name
 */
function NamedStyle(name) {
    return new DandelionCssBuilder(name);
}

/**
 * Set style for the root element (`<html>`).
 * @param  {...CssProperty} properties
 */
function RootStyle(...properties) {
    return new DandelionCssBuilder().noName().properties(
        new Pseudoclass("root").define(...properties),
    );
}

/**
 * Set style for all elements.
 * @param  {...CssProperty} properties
 */
function AllElementStyle(...properties) {
    return new DandelionCssBuilder("*").properties(...properties);
}

export {
    acos,
    AlignItems,
    AlignItems as VerticalAlignment,
    AllElementStyle,
    Anchor,
    Appearance,
    asin,
    atan,
    atan2,
    attr,
    BackgroundColor,
    BackgroundImage,
    BackgroundSize,
    blur,
    borderBox,
    BorderCollapse,
    BorderColor,
    BorderRadius,
    BorderSize,
    BorderStyle,
    BoxSizing,
    brightness,
    ButtonColorStyle,
    calc,
    circle,
    color,
    colorMix,
    conicGradient,
    contentBox,
    contrast,
    cos,
    counter,
    counters,
    counterStyle,
    crossFade,
    cssVar,
    cubicBezier,
    cursorUrl,
    DisplayMode,
    DisplayMode as Visibility,
    dropShadow,
    element,
    ellipse,
    exp,
    fillBox,
    fitContent,
    FixedElement,
    fontFaceSrc,
    FontFamily,
    FontSize,
    FontStretch,
    FontStyle,
    FontVariant,
    FontWeight,
    ForegroundColor,
    ForegroundColor as FontColor,
    format,
    frames,
    GetMixedColorsAndStyle,
    grayscale,
    hsl,
    hsla,
    hueRotate,
    hwb,
    hypot,
    image,
    imageSet,
    inset,
    invert,
    JustifyContent,
    JustifyContent as HorizontalAlignment,
    lab,
    lch,
    leader,
    lightDark,
    linearGradient,
    lineGradient,
    log,
    Margin,
    Margin as ExternalMargin,
    marginBox,
    matrix,
    matrix3d,
    max,
    MediaQuery,
    MediaQuery as StyleCondition,
    min,
    minmax,
    MixColors,
    mod,
    NamedStyle,
    oklab,
    oklch,
    opacity,
    OutlineColor,
    OutlineOffset,
    OutlineRadius,
    OutlineSize,
    OutlineStyle,
    Overflow,
    Padding,
    Padding as InternalMargin,
    paddingBox,
    path,
    perspective,
    polygon,
    Position,
    pow,
    Pseudoclass,
    Pseudoclass as ElementState,
    radialGradient,
    ray,
    rect,
    rem,
    repeat,
    repeatingConicGradient,
    repeatingLinearGradient,
    repeatingRadialGradient,
    rgb,
    rgba,
    RootStyle,
    rotate,
    rotate3d,
    rotateX,
    rotateY,
    rotateZ,
    round,
    saturate,
    scale,
    scale3d,
    scaleX,
    scaleY,
    scaleZ,
    sepia,
    ShadowDrop,
    Size,
    skew,
    skewX,
    skewY,
    sqrt,
    steps,
    StickyElement,
    strokeBox,
    Style,
    symbols,
    tan,
    toggle,
    translate,
    translate3d,
    translateX,
    translateY,
    translateZ,
    url,
    varInCalc,
    viewBox,
    ZIndex,
};
