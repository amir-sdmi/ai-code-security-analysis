const express = require('express');
const multer = require('multer');
const axios = require('axios');
const router = express.Router();

// Multer setup for image and PDF uploads
const storage = multer.memoryStorage();
const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/') || file.mimetype === 'application/pdf') {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only images and PDFs are allowed.'), false);
    }
  }
});

// Google Gemini API configuration for Gemini 1.5 Flash
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || 'AIzaSyCJGB5_n4hUOhgRGd3kyjlG8_7B37T0JlU'; // Use environment variable or provided API key
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent'; // Use Gemini 1.5 Flash model

// POST /transactions/upload/upload-image
router.post('/upload-image', (req, res, next) => {
  upload.single('file')(req, res, (err) => {
    if (err instanceof multer.MulterError) {
      if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ message: 'File size too large. Maximum size is 10MB.' });
      }
      return res.status(400).json({ message: 'File upload error: ' + err.message });
    } else if (err) {
      return res.status(400).json({ message: err.message });
    }
    next();
  });
}, async (req, res) => { // Changed 'image' to 'file'
  if (!req.file) {
    return res.status(400).json({ message: 'No file provided.' }); // Updated message
  }

  if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY') { // Updated check
    console.error('Gemini API key is not configured.');
    return res.status(500).json({ message: 'AI service is not configured on the server.' });
  }

  try {
    // Validate file size (limit to 10MB)
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (req.file.size > maxSize) {
      return res.status(400).json({ message: 'File size too large. Maximum size is 10MB.' });
    }

    // Additional validation for PDF files
    if (req.file.mimetype === 'application/pdf') {
      // Check if the PDF buffer has the PDF header
      const pdfHeader = req.file.buffer.slice(0, 4).toString();
      if (pdfHeader !== '%PDF') {
        return res.status(400).json({ message: 'Invalid PDF file format.' });
      }
    }

    // Convert file buffer to base64
    const fileBase64 = req.file.buffer.toString('base64'); // Changed variable name

    // Prepare the prompt and file data for the Gemini model
    const requestPayload = {
      contents: [
        {
          parts: [
            { text: 'Analyze the following document (image or PDF) and extract the total amount, category (e.g., groceries, fuel, food, shopping), date, payment type (e.g., cash, credit card, debit card), and a brief description of the transaction. Return the data in a clean JSON format like this:\n{\n  "amount": 123.45,\n  "category": "Groceries",\n  "date": "YYYY-MM-DD",\n  "paymentType": "Credit Card",\n  "description": "Brief description of items purchased"\n}' }, // Updated text prompt part to include payment type and description and mention PDF
            {
              inline_data: { // File data part
                mime_type: req.file.mimetype,
                data: fileBase64 // Changed variable name
              }
            }
          ]
        }
      ]
    };

    // Call the Google Gemini Inference API
    const geminiResponse = await axios.post(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, requestPayload, // Send payload
      {
        headers: {
          'Content-Type': 'application/json',
        },
      }
    );

    // Extract the generated text from the response
    // Gemini response structure: response.data.candidates[0].content.parts[0].text
    const generatedText = geminiResponse.data?.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
        console.error('No text generated by Gemini:', geminiResponse.data);
        throw new Error('AI service did not generate text.');
    }

    // Clean the response to extract only the JSON part
    // Assuming Gemini might also wrap JSON in code blocks
    const jsonMatch = generatedText.match(/```json\n([\s\S]*?)\n```/);

    if (!jsonMatch || !jsonMatch[1]) {
        console.error('Could not find JSON in Gemini response:', generatedText);
        // Fallback: try parsing the whole text if no code block is found
        try {
            const extractedData = JSON.parse(generatedText);
             res.json(extractedData);
             return;
        } catch (parseError) {
             console.error('Could not parse generated text as JSON:', parseError);
             throw new Error('Invalid response format from AI service.');
        }
    }

    const jsonString = jsonMatch[1];
    const extractedData = JSON.parse(jsonString);

    // Return the extracted data to the frontend
    res.json(extractedData);

  } catch (error) {
    console.error('Error processing file with Gemini API:', error.response ? error.response.data : error.message);
    
    // Handle specific Gemini API errors
    if (error.response && error.response.data && error.response.data.error) {
      const geminiError = error.response.data.error;
      
      if (geminiError.code === 400) {
        if (geminiError.message.includes('no pages')) {
          return res.status(400).json({ 
            message: 'The PDF file appears to be empty or corrupted. Please try uploading a different file.' 
          });
        } else if (geminiError.message.includes('format')) {
          return res.status(400).json({ 
            message: 'The file format is not supported. Please upload a valid image or PDF file.' 
          });
        }
      }
    }
    
    // Generic error message for other cases
    res.status(500).json({ message: 'Failed to extract transaction from file using AI.' });
  }
});

// POST /transactions/upload/upload-pdf-table - New endpoint for PDF table extraction
router.post('/upload-pdf-table', (req, res, next) => {
  upload.single('file')(req, res, (err) => {
    if (err instanceof multer.MulterError) {
      if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ message: 'File size too large. Maximum size is 10MB.' });
      }
      return res.status(400).json({ message: 'File upload error: ' + err.message });
    } else if (err) {
      return res.status(400).json({ message: err.message });
    }
    next();
  });
}, async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: 'No PDF file provided.' });
  }

  // Validate that it's a PDF file
  if (req.file.mimetype !== 'application/pdf') {
    return res.status(400).json({ message: 'Only PDF files are allowed for tabular extraction.' });
  }

  if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY') {
    console.error('Gemini API key is not configured.');
    return res.status(500).json({ message: 'AI service is not configured on the server.' });
  }

  try {
    // Validate file size
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (req.file.size > maxSize) {
      return res.status(400).json({ message: 'File size too large. Maximum size is 10MB.' });
    }

    // Check if the PDF buffer has the PDF header
    const pdfHeader = req.file.buffer.slice(0, 4).toString();
    if (pdfHeader !== '%PDF') {
      return res.status(400).json({ message: 'Invalid PDF file format.' });
    }

    // Convert file buffer to base64
    const fileBase64 = req.file.buffer.toString('base64');

    // Prepare the prompt for tabular transaction extraction
    const requestPayload = {
      contents: [
        {
          parts: [
            { 
              text: `Analyze the following PDF document and extract ALL transactions from any tables or transaction lists. 
              Return the data as a JSON array with the following structure:
              {
                "transactions": [
                  {
                    "date": "YYYY-MM-DD",
                    "amount": 123.45,
                    "description": "transaction description",
                    "category": "inferred category like groceries, fuel, utilities, etc.",
                    "paymentMethod": "inferred payment method like cash, credit card, debit card, etc."
                  }
                ],
                "summary": {
                  "totalTransactions": 5,
                  "totalAmount": 567.89,
                  "dateRange": "2024-01-01 to 2024-01-31",
                  "extractedFrom": "bank statement or document type"
                }
              }
              
              Instructions:
              - Extract ALL transactions found in the document
              - Convert all amounts to positive numbers
              - Infer categories based on merchant names or descriptions
              - Infer payment methods when possible
              - Use proper date format (YYYY-MM-DD)
              - Include brief but descriptive transaction descriptions
              - If no transactions found, return empty array
              - Be thorough and extract every transaction visible in the document` 
            },
            {
              inline_data: {
                mime_type: req.file.mimetype,
                data: fileBase64
              }
            }
          ]
        }
      ]
    };

    // Call the Google Gemini API
    const geminiResponse = await axios.post(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, requestPayload, {
      headers: {
        'Content-Type': 'application/json',
      },
      timeout: 60000, // 60 second timeout for PDF processing
    });

    // Extract the generated text from the response
    const generatedText = geminiResponse.data?.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      console.error('No text generated by Gemini:', geminiResponse.data);
      throw new Error('AI service did not generate text.');
    }

    // Clean the response to extract only the JSON part
    const jsonMatch = generatedText.match(/```json\n([\s\S]*?)\n```/);
    let extractedData;

    if (!jsonMatch || !jsonMatch[1]) {
      console.log('No JSON code block found, attempting to parse full response');
      // Try to find JSON in the response
      const jsonStart = generatedText.indexOf('{');
      const jsonEnd = generatedText.lastIndexOf('}') + 1;
      
      if (jsonStart !== -1 && jsonEnd > jsonStart) {
        const jsonString = generatedText.substring(jsonStart, jsonEnd);
        extractedData = JSON.parse(jsonString);
      } else {
        throw new Error('Could not extract JSON from AI response');
      }
    } else {
      const jsonString = jsonMatch[1];
      extractedData = JSON.parse(jsonString);
    }

    // Validate and process extracted data
    const transactions = extractedData.transactions || [];
    const validTransactions = [];
    const invalidTransactions = [];

    transactions.forEach((transaction, index) => {
      const errors = [];
      
      // Validate required fields
      if (!transaction.amount || isNaN(parseFloat(transaction.amount))) {
        errors.push('Invalid amount');
      }
      
      if (!transaction.date) {
        errors.push('Missing date');
      } else {
        // Validate date format
        const date = new Date(transaction.date);
        if (isNaN(date.getTime())) {
          errors.push('Invalid date format');
        }
      }
      
      if (!transaction.description || transaction.description.trim() === '') {
        errors.push('Missing description');
      }

      // Add default values for missing optional fields
      if (!transaction.category) {
        transaction.category = 'Other';
      }
      
      if (!transaction.paymentMethod) {
        transaction.paymentMethod = 'Other';
      }

      if (errors.length === 0) {
        validTransactions.push({
          ...transaction,
          amount: parseFloat(transaction.amount),
          description: transaction.description.trim(),
          category: transaction.category.trim(),
          paymentMethod: transaction.paymentMethod.trim()
        });
      } else {
        invalidTransactions.push({
          ...transaction,
          errors,
          index: index + 1
        });
      }
    });

    // Prepare response
    const responseData = {
      success: true,
      data: {
        validTransactions,
        invalidTransactions,
        totalFound: transactions.length,
        totalValid: validTransactions.length,
        totalInvalid: invalidTransactions.length,
        summary: extractedData.summary || {
          totalTransactions: transactions.length,
          totalAmount: validTransactions.reduce((sum, t) => sum + t.amount, 0),
          extractedFrom: 'PDF Document'
        }
      }
    };

    res.json(responseData);

  } catch (error) {
    console.error('Error processing PDF with Gemini API:', error);
    
    // Handle specific errors
    if (error.response && error.response.data && error.response.data.error) {
      const geminiError = error.response.data.error;
      
      if (geminiError.code === 400) {
        if (geminiError.message.includes('no pages')) {
          return res.status(400).json({ 
            message: 'The PDF file appears to be empty or corrupted. Please try uploading a different file.' 
          });
        } else if (geminiError.message.includes('format')) {
          return res.status(400).json({ 
            message: 'The file format is not supported. Please upload a valid PDF file.' 
          });
        }
      }
    }
    
    // Generic error message for other cases
    res.status(500).json({ 
      success: false,
      message: 'Failed to extract transaction table from PDF. Please ensure the PDF contains readable transaction data.' 
    });
  }
});

module.exports = router;
