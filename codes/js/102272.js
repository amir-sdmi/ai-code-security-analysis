// Comments are generated by ChatGPT, so they may be a little inaccurate
if("harvesters" in Memory != true) {
    // Initialization of memory properties for the first loop
    console.log("first time loop is restarted");
    Memory.longRangeBuilders = new Array();
    Memory.claimers = new Array();
    Memory.LRMpaths = new Object();
    Memory.fighters = new Array();
    Memory.haulers = new Array();
    Memory.assignedids = 0;
    Memory.usedsources = new Array();
    Memory.buildersources = new Array();
    Memory.upgradersources = new Array();
    Memory.builderlevel = 1;
}
if("storedcreeps" in Memory != true) {
    // Initialization of memory properties for stored creeps and mining
    console.log("loading long range miners!");
    Memory.storedcreeps = [];
    Memory.segmentRequests = [];
    Memory.longrangemining = [];
    Memory.longrangeminingcreeps = [];
}

// Setup mining rooms and global update lists
Memory.miningrooms = [
    {room: "E52S19", usedSegment: 0},
    {room: "E53S17", usedSegment: 0},
    {room: "E53S18", usedSegment: 0},
    {room: "E51S19", usedSegment: 0},
    {room: "E51S18", usedSegment: 0}
];
global.nextupdate = [];
global.nexttick = [];
global.avgcpu = []

// Import necessary modules for various roles and functions
var harvestercode = require('role.harvester');
var unithandler = require("handler.newunits");
var buildercode = require("role.builder");
var combatcode = require("role.combat");
var register = require("general.sourceregistering");
var longbuild = require("role.longrangebuilder");
var minercode = require("role.longrangeminer");
var funcs = require("general.functions");
var haulercode = require("role.hauler")
var minharv = require("role.mineralharv")
var terminal = require("terminalCalculator")
var linkcode = require("structure.link")
require("./spawnUtils")
var queencode = require("role.queen");
const { isUndefined } = require('lodash');
if(global.fixticks === undefined) {
    global.fixticks = 0
}
global.updatecache = 400
console.log("restarting loop");
//var ramparttest = require("rampartcalc")
//console.log(ramparttest.findOptimalRamparts(Game.rooms["E52S18"]))
module.exports.loop = function () {
    if(Game.cpu.bucket < 500) {
        console.log("extremely low cpu bucket, terminating")
        return
    }
    RawMemory.setActiveSegments([1]);
    Memory.haulerlevel = 0
    global.fixticks += 1
    global.updatecache += 1
    if(global.restartEco!==undefined) console.log("consolidating eco to "+global.restartEco)
    if(global.updatecache > 400) {
        console.log("updating cache")
        let full = 0
        for(const T in Memory.longrangemining) {
            let I = Memory.longrangemining[T]
            for(const name in I.creeps) {
                creep = Game.creeps[I.creeps[name]]
                if(creep === undefined) {

                } else {
                    let dist = funcs.getTrueDistance(new RoomPosition(Game.spawns.Spawn1.pos.x,Game.spawns.Spawn1.pos.y,Game.spawns.Spawn1.room.name),new RoomPosition(creep.pos.x,creep.pos.y,creep.room.name))
                    full += dist
                }
            }
        }
        let multi=0
        for(key in Game.spawns) multi+=1
        Memory.haulerneeded = (Math.round((full)/2.5))
        global.updatecache = 0
    }
    if(global.defenseNeeded >= 1) {
        console.log("defense required")
    }

    global.haulercreations = 0
    for(temp in Memory.longrangemining) {
        global.haulercreations += Memory.longrangemining[temp].creeps.length
    }
    //Gather info on which spawn for haulers to focus on
    global.haulerfocus=0
    let grab = 0
    let info = 1000000000000000
    let keyfix = Game.spawns
    let spawnamount = 0
    for(let a in Game.spawns) {
        spawnamount+=1
    }
    for(let temp in Game.spawns) {
        let spawn = Game.spawns[temp]
        if(spawn.room.storage) {
            if(spawn.room.storage.store[RESOURCE_ENERGY]<info&&(spawn.memory.queen!==undefined||spawn.memory.queen2!==undefined)||spawnamount<=1) {
                grab=temp
                info=spawn.room.storage.store[RESOURCE_ENERGY]
            }
        }
    }
    global.haulerfocus=grab
    // Loop through each spawn and manage units and tasks
    for(let spawnid in Game.spawns) {

        global.createdunit = 0
        let currentspawn = Game.spawns[spawnid];

        if(currentspawn.memory.harvesters === undefined) {
            currentspawn.memory = {
                harvesters: [],
                builders: [],
                itemrequests: [],
                builderallocations: { upgrade: 0, buildRoad: 0, general: 0 }
            }
        }
        let test = currentspawn.room.find(FIND_STRUCTURES, {
            filter: (structure) => {
                return (structure.structureType == STRUCTURE_EXTRACTOR)
            }
        })
        if(test.length > 0)  {
            global.isextractor = test[0].id;
        } else global.isextractor = undefined
        // Cache the number of extensions in the spawn's room
        Memory.storecache = currentspawn.room.find(FIND_STRUCTURES, {
            filter: (structure) => {
                return (structure.structureType == STRUCTURE_EXTENSION);
            }
        }).length;
        let towers = currentspawn.room.find(FIND_STRUCTURES, {
            filter: (structure) => {
                return (structure.structureType == STRUCTURE_TOWER)
            }
        });
        if(Game.cpu.bucket < 2000) {
            console.log("low bucket, disabling non-needed codebases")
        }
            for(let towerold in towers) {
                let tower = towers[towerold]
                let attackers = tower.room.find(FIND_HOSTILE_CREEPS, {filter: function(creep) {
                    return creep.owner.username !== "chungus3095"
                }})
                if(attackers.length > 0) {
                    attackers.sort((a, b) => b.hits - a.hits);
                    tower.attack(attackers[0])
                } else {
                    let targets = tower.room.find(FIND_STRUCTURES, {
                        filter: object => object.hits < object.hitsMax*0.75 && object.hits < 1000000
                    });
                    
                    // Sort by damage level (most damaged first)
                    targets.sort((a, b) => a.hits - b.hits);
                    
                    // If damaged structures are found, repair the closest one
                    if(targets.length > 0) {
                        tower.repair(targets[0])
                    }
                }
                
            }
        let alllinks = currentspawn.room.find(FIND_MY_STRUCTURES,{filter: function(structure) {
            return structure.structureType === STRUCTURE_LINK
        }})
        for(let I in alllinks) {
            linkcode.tick(alllinks[I]);
        }
        // Set cache to 0 if the controller level is 1
        if(currentspawn.room.controller.level == 1) {
            Memory.storecache = 0;
        }
        global.kill = 0
        if(Game.cpu.bucket >= 2000) {
            if(currentspawn.room.controller.level > 2) {
                let add = 0
                for(let temp in Memory.miningrooms) {
                    let I = Memory.miningrooms[temp]
                    if(I.room ==currentspawn.room.name) {
                        add = 1
                    }
                }
                if(add == 0) {
                    Memory.miningrooms.push({room:currentspawn.room.name, usedSegment: 0})
                }
            }
        }
        // Check for new harvester, builder, and combat units
        currentspawn.queueCheck()
        unithandler.newharvcheck(spawnid);
        unithandler.newbuildcheck(spawnid);
        unithandler.newhaulercheck(spawnid);
        unithandler.newcombatcheck(spawnid);
        global.defenseNeeded -=1
        // Run through each harvester in memory and execute its tasks
        try {
            for(let I in Memory.haulers) {
                if(Game.creeps[Memory.haulers[I]].ticksToLive<1000) {
                    currentspawn.renewCreep(Game.creeps[Memory.haulers[I]])
                }
            }
        } catch(e) {}
        // ||||||||||||||||||||||
        // run for each unit type
        // ||||||||||||||||||||||
        if(Game.spawns[spawnid].memory.harvesters.length > 0) {
            Game.spawns[spawnid].memory.harvesters.forEach(item => harvesterforeach(item, spawnid));
        }
        // Run through each builder in memory and execute its tasks
        if(Game.spawns[spawnid].memory.builders.length > 0) {
            Game.spawns[spawnid].memory.builders.forEach(item => builderforeach(item, spawnid));
        }
        if(Game.cpu.bucket >= 2000) {
            if(currentspawn.memory.minharvs) {
                Game.spawns[spawnid].memory.minharvs.forEach(item => minharvsforeach(item, spawnid));
            }
        }
        if(currentspawn.memory.queen !== undefined) {
            if(currentspawn.memory.queen in Game.creeps) {
                queencode.tick(Game.creeps[currentspawn.memory.queen],"queen1")
            } else {
                currentspawn.memory.queen = undefined
            }
        }
        if(Game.cpu.bucket >= 2000) {
            if(currentspawn.memory.queen2 !== undefined) {
                if(currentspawn.memory.queen2 in Game.creeps) {
                    queencode.tick(Game.creeps[currentspawn.memory.queen2],"queen2")
                } else {
                    currentspawn.memory.queen2 = undefined
                }
            }
            if(currentspawn.room.terminal!==undefined) {
                terminal.tick(currentspawn.room.terminal)
        }
        }
    }
    if(Memory.haulers.length > 0) {
        Memory.haulers.forEach(item => haulerforeach(item,global.haulerfocus));
    }
    if(Game.cpu.bucket >= 2000) {
        for(let temp in Memory.claimers) {
            let claimer = Game.creeps[Memory.claimers[temp]]
            if(claimer === undefined) {
                Memory.claimers[temp] = undefined
                continue
            }
            if(claimer.memory.reserving !== undefined) {
                if(claimer.room.name !== claimer.memory.reserving) {
                    claimer.moveTo(new RoomPosition(25,25,claimer.memory.reserving),{reusePath:40})
                } else {
                    let check = claimer.room.find(FIND_STRUCTURES,{filter: function(structure) {
                        return structure.structureType == STRUCTURE_CONTROLLER
                    }})
                    if(check) {
                        if(claimer.reserveController(check[0]) == ERR_NOT_IN_RANGE) claimer.moveTo(check[0])
                    }
                }
            } else {
                claimer.memory.reserving = Memory.miningrooms[temp].room
            }
        }
        for(let temp in Memory.longRangeBuilders) {
            let Lbuilder  = Memory.longRangeBuilders[temp]
            if(Game.creeps[Lbuilder] === undefined) {
                Memory.longRangeBuilders = funcs.Lremove(Memory.longRangeBuilders,temp)
                continue
            }
            longbuild.tick(Game.creeps[temp])
        }
    }
    // Run the miner code for long-range mining logic
    minercode.tick();
    // ||||||||||||||||||||||
    //  Unit type running end
    // ||||||||||||||||||||||

    // Clear stored creeps if the first stored creep is undefined
    if(Game.creeps[Memory.storedcreeps[0]] === undefined) {
        Memory.storedcreeps = [];
    } else {
        Game.creeps[Memory.storedcreeps[0]].moveTo(9,5,{reusePath: 40})
    }

    // Cleanup memory for creeps that no longer exist
    for(let curcreep in Memory.creeps) {
        if(isUndefined(Game.creeps[curcreep])) {
            Memory.creeps[curcreep] = undefined;
        }
    }


    if(global.fixticks > 1000) {
        Memory.usedsources = new Array();
        Memory.buildersources = new Array();
        Memory.upgradersources = new Array();
        console.log("!! forcefully resetting source allocations, to fix any issues that arise while offline")
        global.fixticks = 0
    }

        // Run through each fighter in memory and execute its tasks
        if(Memory.fighters.length > 0) {
            Memory.fighters.forEach(item => combatforeach(item));
        }
    // Log CPU usage with different warnings based on usage level
    let ecolevel = 3
    if(global.restartEco!==undefined) {
        ecolevel = 2
    }
    if(Memory.haulers.length < 4) {
        ecolevel = 1
    }
    if(Memory.haulers.length < 1) {
        ecolevel = 0
    }
    global.avgcpu.push(Game.cpu.getUsed())
    let avg = array => array.reduce((a, b) => a + b) / array.length;
    let stringify = {
        cpuUsage: avg(avgcpu),
        bucket: Game.cpu.bucket,
        ecoStatus: ecolevel
    }
    if(global.avgcpu.length>14) {
        global.avgcpu.splice(0,1)
    }
    RawMemory.segments[1] = JSON.stringify(stringify)
    if(Game.cpu.getUsed() >= 20) {
        console.log("tf are you doing, you're at the max cpu! (" + Game.cpu.getUsed() + ")");
    }
}

// Function to handle tasks for each harvester
function harvesterforeach(item, spawntype) {
    if(item in Game.creeps) {
        if(Game.creeps[item].room == Game.spawns[spawntype].room) {
            // Renew harvester if it's near the end of its lifespan
            if(Game.creeps[item].ticksToLive < 1000) { 
                Game.spawns[spawntype].renewCreep(Game.creeps[item]);
            }
            // Execute harvester tasks
            if(global.kill==1) {
                register.remove("usedsources",Game.creeps[item])
                Game.creeps[item].suicide()
            } else {
                harvestercode.run(Game.creeps[item]);
            }
        } 
    } else {
        // Remove harvester from memory if it no longer exists
        Memory.creeps[item] = undefined;
        const index = Game.spawns[spawntype].memory.harvesters.indexOf(item);
        if (index > -1) {
            console.log("epic");
            Game.spawns[spawntype].memory.harvesters.splice(index, 1); 
        }
    }
}

// Function to handle tasks for each hauler
function haulerforeach(item,focuson) {
    if(item in Game.creeps) {
            // Renew hauler if it's near the end of its lifespan
            // Execute hauler tasks
            haulercode.tick(Game.creeps[item],focuson);
    } else {
        // Remove harvester from memory if it no longer exists
        Memory.creeps[item] = undefined;
        const index = Memory.haulers.indexOf(item);
        if (index > -1) {
            console.log("epic");
            Memory.haulers.splice(index, 1); 
        }
    }
}

// Function to handle tasks for each builder
function builderforeach(item, spawntype) {
    if(item in Game.creeps) {
            // Renew builder if it's near the end of its lifespan
            if(Game.creeps[item].ticksToLive < 1000) { 
                Game.spawns[spawntype].renewCreep(Game.creeps[item]);
            }
            // Execute builder tasks
            buildercode.run(Game.creeps[item], spawntype);
    } else {
        // Manage memory cleanup and task allocations if builder no longer exists
        const index =Game.spawns[spawntype].memory.builders.indexOf(item);
        var data = Memory.creeps[item];
        data = {memory: data};
        Memory.creeps[item] = undefined;
        if(data.memory != undefined) {
            if(data.memory.task != undefined) {
                console.log(data.memory.task);
                Game.spawns[spawntype].memory.builderallocations[data.memory.task] -= 1;
                if(data.memory.task == 'general') {
                    register.remove("buildersources", data);
                }
                if(data.memory.task == 'upgrade') {
                    register.remove("upgradersources", data);
                }
                data.memory.task = undefined;
            }
        }
        if (index > -1) {
            console.log("test");
            Game.spawns[spawntype].memory.builders.splice(index, 1); 
        }
    }
}

// Function to handle tasks for each combat unit
function combatforeach(item) {
    if(item in Game.creeps) {
        // Renew combat unit if it's near the end of its lifespan
        // Execute combat unit tasks
        combatcode.run(Game.creeps[item]);
    } else {
        // Remove combat unit from memory if it no longer exists
        Memory.creeps[item] = undefined;
        const index = Memory.fighters.indexOf(item);
        if (index > -1) {
            Memory.fighters.splice(index, 1); 
        }
    }
}
function minharvsforeach(item,spawntype) {
    if(item in Game.creeps) {
            // Renew hauler if it's near the end of its lifespan
            // Execute hauler tasks
            minharv.run(Game.creeps[item]);
    } else {
        // Remove harvester from memory if it no longer exists
        Memory.creeps[item] = undefined;
        const index = Game.spawns[spawntype].memory.minharvs.indexOf(item);
        if (index > -1) {
            console.log("epic");
            Game.spawns[spawntype].memory.minharvs.splice(index, 1); 
        }
    }
}