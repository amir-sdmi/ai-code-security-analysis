const express = require('express');
const cors = require('cors');
const axios = require('axios');
const config = require('./config');

const app = express();

// Enable CORS for all routes
app.use(cors({
  origin: config.CORS_ORIGIN
}));
app.use(express.json());

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'Gemini AI Proxy is running',
    environment: config.NODE_ENV,
    hasApiKey: !!config.GEMINI_API_KEY,
    endpoints: [
      '/api/generate-text',
      '/api/generate-image'
    ]
  });
});

// Text generation endpoint
app.post('/api/generate-text', async (req, res) => {
  try {
    const { 
      prompt, 
      model = 'gemini-1.5-flash',
      temperature = 0.7,
      maxTokens = 1000,
      conversationHistory = []
    } = req.body;

    console.log('Received text generation request:', { 
      prompt: prompt?.substring(0, 100) + '...', 
      model, 
      temperature 
    });

    if (!config.GEMINI_API_KEY) {
      console.error('Gemini API key not configured');
      return res.status(500).json({ error: 'Gemini API key not configured' });
    }

    if (!prompt) {
      return res.status(400).json({ error: 'Prompt is required' });
    }

    console.log('Calling Gemini Text API...');

    // Build the conversation context
    const contents = [];
    
    // Add conversation history if provided
    conversationHistory.forEach((msg, index) => {
      contents.push({
        role: index % 2 === 0 ? 'user' : 'model',
        parts: [{ text: msg }]
      });
    });

    // Add the current prompt
    contents.push({
      role: 'user',
      parts: [{ text: prompt }]
    });

    const requestBody = {
      contents,
      generationConfig: {
        temperature,
        maxOutputTokens: maxTokens,
        topP: 0.8,
        topK: 10
      },
      safetySettings: [
        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
      ]
    };

    const response = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${config.GEMINI_API_KEY}`,
      requestBody,
      {
        headers: {
          'Content-Type': 'application/json',
        },
        timeout: config.REQUEST_TIMEOUT
      }
    );

    console.log('Gemini Text API response received');

    if (!response.data.candidates || response.data.candidates.length === 0) {
      console.error('No candidates in text response:', response.data);
      return res.status(500).json({ error: 'No text generated by Gemini' });
    }

    const candidate = response.data.candidates[0];
    
    if (candidate.finishReason !== 'STOP') {
      console.error('Text generation blocked:', candidate);
      return res.status(400).json({ 
        error: 'Text generation was blocked', 
        reason: candidate.finishReason,
        safetyRatings: candidate.safetyRatings 
      });
    }

    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
      console.error('No content in text response:', candidate);
      return res.status(500).json({ error: 'No content in response' });
    }

    const generatedText = candidate.content.parts[0].text;
    console.log('Text generated successfully, length:', generatedText.length);

    res.json({ 
      text: generatedText,
      success: true,
      metadata: {
        model,
        temperature,
        maxTokens,
        finishReason: candidate.finishReason,
        timestamp: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('Error generating text:', error);
    
    if (axios.isAxiosError(error)) {
      const status = error.response?.status || 500;
      const message = error.response?.data?.error?.message || error.message;
      res.status(status).json({ 
        error: `Gemini API error: ${message}`,
        details: error.response?.data 
      });
    } else {
      res.status(500).json({ 
        error: 'Internal server error',
        message: error.message 
      });
    }
  }
});

// Image generation endpoint
app.post('/api/generate-image', async (req, res) => {
  try {
    const { prompt } = req.body;

    console.log('Received image generation request:', { prompt });

    if (!config.GEMINI_API_KEY) {
      console.error('Gemini API key not configured');
      return res.status(500).json({ error: 'Gemini API key not configured' });
    }

    if (!prompt) {
      return res.status(400).json({ error: 'Prompt is required' });
    }

    console.log('Calling Gemini 2.0 Flash Image Generation API...');
    
    const response = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent?key=${config.GEMINI_API_KEY}`,
      {
        contents: [
          {
            role: 'user',
            parts: [{ text: prompt }]
          }
        ],
        generationConfig: {
          responseModalities: ['TEXT', 'IMAGE'],
          candidateCount: 1
        },
        safetySettings: [
          { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
          { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
          { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
          { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
        ]
      },
      {
        headers: {
          'Content-Type': 'application/json',
        },
        timeout: config.REQUEST_TIMEOUT
      }
    );

    console.log('Gemini API response received');

    if (!response.data.candidates || response.data.candidates.length === 0) {
      console.error('No candidates in response:', response.data);
      return res.status(500).json({ error: 'No image generated by Gemini' });
    }

    const candidate = response.data.candidates[0];
    
    if (candidate.finishReason !== 'STOP') {
      console.error('Image generation blocked:', candidate);
      return res.status(400).json({ 
        error: 'Image generation was blocked', 
        reason: candidate.finishReason,
        safetyRatings: candidate.safetyRatings 
      });
    }

    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
      console.error('No content parts in response:', candidate);
      return res.status(500).json({ error: 'No content parts in response' });
    }

    // Find the image part in the response
    let imagePart = null;
    let textPart = null;
    
    // Look for image and text parts
    for (const part of candidate.content.parts) {
      if (part.inlineData && part.inlineData.mimeType && part.inlineData.mimeType.startsWith('image/')) {
        imagePart = part;
      } else if (part.text) {
        textPart = part;
      }
    }
    
    if (!imagePart) {
      console.error('No image part found in response:', candidate.content.parts);
      return res.status(500).json({ error: 'No image data in response' });
    }

    // Convert base64 image data to data URL
    const imageData = imagePart.inlineData.data;
    const mimeType = imagePart.inlineData.mimeType;
    const imageUrl = `data:${mimeType};base64,${imageData}`;
    
    console.log('Image generated successfully, mime type:', mimeType);
    console.log('Generated text:', textPart?.text || 'No text generated');

    res.json({ 
      imageUrl,
      text: textPart?.text || null,
      success: true,
      metadata: {
        model: 'gemini-2.0-flash-preview-image-generation',
        prompt,
        mimeType,
        timestamp: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('Error generating image:', error);
    
    if (axios.isAxiosError(error)) {
      const status = error.response?.status || 500;
      const message = error.response?.data?.error?.message || error.message;
      res.status(status).json({ 
        error: `Gemini API error: ${message}`,
        details: error.response?.data 
      });
    } else {
      res.status(500).json({ 
        error: 'Internal server error',
        message: error.message 
      });
    }
  }
});

// Catch-all for undefined routes
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

app.listen(config.PORT, () => {
  console.log(`âœ… Gemini AI Proxy Server running on port ${config.PORT}`);
  console.log(`ğŸ“‹ Health check: http://localhost:${config.PORT}/health`);
  console.log(`ğŸ’¬ Text endpoint: http://localhost:${config.PORT}/api/generate-text`);
  console.log(`ğŸ¨ Image endpoint: http://localhost:${config.PORT}/api/generate-image`);
  console.log(`ğŸ”‘ Gemini API Key: ${config.GEMINI_API_KEY ? 'Configured âœ…' : 'Missing âŒ'}`);
  console.log(`ğŸŒ Environment: ${config.NODE_ENV}`);
  console.log(`ğŸš€ CORS Origin: ${config.CORS_ORIGIN}`);
});
