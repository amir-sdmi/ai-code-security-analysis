#!/usr/bin/env node
// Generated by Copilot
/**
 * WikiFlow 2025 Development Iteration Helper
 *
 * This script provides an interactive CLI to streamline the development
 * iteration process for the WikiFlow 2025 project.
 *
 * Features:
 * - Intelligent development server management
 * - Quick access to common development tasks
 * - Error detection and reporting
 * - Performance monitoring
 *
 * Usage: node scripts/flowdev.js
 */

'use strict';

// Using CommonJS modules for compatibility
const { spawn, execSync } = require('child_process');
const { existsSync, readFileSync } = require('fs');
const { dirname, join } = require('path');
const readline = require('readline');
const chalk = require('chalk');

// Get the current file's directory
const __dirname = dirname(__filename);
const rootDir = join(__dirname, '..');

// Define terminal colors
const colors = {
  info: chalk.blue,
  success: chalk.green,
  warning: chalk.yellow,
  error: chalk.red,
  highlight: chalk.cyan,
  bold: chalk.bold,
};

// Track running processes
const runningProcesses = new Map();

/**
 * Logger utility for consistent output styling
 */
const logger = {
  info: (message) => console.log(colors.info('[FlowDev]'), message),
  success: (message) => console.log(colors.success('[✓]'), message),
  warning: (message) => console.log(colors.warning('[!]'), message),
  error: (message) => console.log(colors.error('[✗]'), message),
  highlight: (message) => console.log(colors.highlight(message)),
  title: (message) => {
    console.log(
      '\n' + colors.bold(colors.highlight('='.repeat(message.length + 4))),
    );
    console.log(colors.bold(colors.highlight(`| ${message} |`)));
    console.log(
      colors.bold(colors.highlight('='.repeat(message.length + 4))) + '\n',
    );
  },
};

/**
 * Error handling wrapper for async functions
 * @param {Function} fn - Function to wrap with error handling
 */
const withErrorHandling =
  (fn) =>
  async (...args) => {
    try {
      return await fn(...args);
    } catch (error) {
      logger.error(`Operation failed: ${error.message}`);
      if (error.stack) {
        logger.info('Stack trace:');
        console.error(error.stack.split('\n').slice(1).join('\n'));
      }
      return null;
    }
  };

/**
 * Run a command in a child process
 * @param {string} command - Command to run
 * @param {string[]} args - Command arguments
 * @param {Object} options - Additional options
 * @returns {Promise<Object>} - Process object
 */
const runCommand = withErrorHandling(
  async (command, args = [], options = {}) => {
    const {
      name = command,
      captureOutput = false,
      silent = false,
      cwd = rootDir,
    } = options;

    if (!silent) {
      logger.info(`Running ${name}: ${command} ${args.join(' ')}`);
    }

    const stdout = captureOutput ? [] : undefined;
    const stderr = captureOutput ? [] : undefined;

    const childProcess = spawn(command, args, {
      cwd,
      stdio: captureOutput ? 'pipe' : 'inherit',
      shell: true,
    });

    if (captureOutput) {
      childProcess.stdout.on('data', (data) => {
        stdout.push(data.toString());
      });

      childProcess.stderr.on('data', (data) => {
        stderr.push(data.toString());
      });
    }

    return new Promise((resolve, reject) => {
      childProcess.on('close', (code) => {
        if (code !== 0 && !options.ignoreErrors) {
          reject(
            new Error(
              `Command '${command} ${args.join(' ')}' failed with exit code ${code}`,
            ),
          );
          return;
        }

        if (captureOutput) {
          resolve({
            code,
            stdout: stdout.join(''),
            stderr: stderr.join(''),
          });
        } else {
          resolve({ code, process: childProcess });
        }
      });

      childProcess.on('error', (error) => {
        reject(error);
      });
    });
  },
);

/**
 * Start the development servers
 */
const startDevServer = withErrorHandling(async () => {
  logger.title('Starting Development Servers');

  // Kill any existing processes
  stopAllProcesses();

  // Start both frontend and backend
  logger.info('Starting frontend and backend servers...');
  const devProcess = spawn('pnpm', ['dev'], {
    cwd: rootDir,
    stdio: 'inherit',
    shell: true,
    detached: false,
  });

  runningProcesses.set('dev', devProcess);

  devProcess.on('close', (code) => {
    if (code !== null && code !== 0) {
      logger.error(`Development server exited with code ${code}`);
    }
    runningProcesses.delete('dev');
  });

  logger.success('Development servers started');
  logger.info('Press Ctrl+C in the terminal to stop the servers');

  return devProcess;
});

/**
 * Stop all running processes
 */
const stopAllProcesses = () => {
  for (const [name, process] of runningProcesses.entries()) {
    logger.info(`Stopping ${name} process...`);

    // Different handling based on platform
    if (process.pid) {
      try {
        // On Unix systems, negative PID kills the process group
        process.kill('SIGTERM');
        logger.success(`${name} process stopped`);
      } catch (error) {
        logger.error(`Failed to stop ${name} process: ${error.message}`);
      }
    }

    runningProcesses.delete(name);
  }
};

/**
 * Run the status check script
 */
const checkStatus = withErrorHandling(async () => {
  logger.title('Checking Project Status');

  // Use the existing flowstatus.sh script
  const result = await runCommand('bash', ['scripts/flowstatus.sh']);

  if (result.code === 0) {
    logger.success('Status check completed successfully');
  }

  return result;
});

/**
 * Run lint checks
 */
const runLint = withErrorHandling(async () => {
  logger.title('Running Lint Checks');

  // Get the list of linting tasks
  const packages = ['frontend', 'backend', 'drizzle'];

  for (const pkg of packages) {
    if (existsSync(join(rootDir, pkg))) {
      logger.info(`Linting ${pkg}...`);

      try {
        await runCommand('pnpm', ['--filter', pkg, 'lint'], {
          name: `${pkg} lint`,
        });
        logger.success(`${pkg} lint completed`);
      } catch (error) {
        logger.error(`${pkg} lint failed: ${error.message}`);
      }
    }
  }

  logger.success('Lint checks completed');
});

/**
 * Build the project
 */
const buildProject = withErrorHandling(async () => {
  logger.title('Building Project');

  const packages = ['frontend', 'backend'];

  for (const pkg of packages) {
    logger.info(`Building ${pkg}...`);

    try {
      await runCommand('pnpm', ['--filter', pkg, 'build'], {
        name: `${pkg} build`,
      });
      logger.success(`${pkg} build completed`);
    } catch (error) {
      logger.error(`${pkg} build failed: ${error.message}`);
      return false;
    }
  }

  logger.success('Build completed successfully');
  return true;
});

/**
 * Run database migrations
 */
const runMigrations = withErrorHandling(async () => {
  logger.title('Running Database Migrations');

  if (!existsSync(join(rootDir, 'drizzle'))) {
    logger.error('Drizzle directory not found');
    return false;
  }

  try {
    // Check if migrations are needed
    const result = await runCommand(
      'pnpm',
      ['--filter', 'drizzle', 'drizzle-kit', 'generate:sqlite'],
      {
        name: 'check migrations',
        captureOutput: true,
      },
    );

    if (result.stdout && result.stdout.includes('No schema changes detected')) {
      logger.success('No database migrations needed');
      return true;
    }

    // Run migration
    await runCommand(
      'pnpm',
      ['--filter', 'drizzle', 'drizzle-kit', 'push:sqlite'],
      {
        name: 'run migration',
      },
    );

    logger.success('Database migrations completed successfully');
    return true;
  } catch (error) {
    logger.error(`Database migration failed: ${error.message}`);
    return false;
  }
});

/**
 * Interactive menu for development iteration
 */
const showIterationMenu = async () => {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const askQuestion = (question) => {
    return new Promise((resolve) => {
      rl.question(question, (answer) => {
        resolve(answer);
      });
    });
  };

  while (true) {
    logger.title('WikiFlow 2025 Development Iteration');

    console.log(colors.bold('Choose an action:'));
    console.log('1. Start development servers');
    console.log('2. Check project status');
    console.log('3. Run lint checks');
    console.log('4. Build project');
    console.log('5. Run database migrations');
    console.log('6. Run all (lint, build, migrations)');
    console.log('7. Exit');

    const answer = await askQuestion('\nEnter option (1-7): ');

    switch (answer.trim()) {
      case '1':
        await startDevServer();
        break;
      case '2':
        await checkStatus();
        break;
      case '3':
        await runLint();
        break;
      case '4':
        await buildProject();
        break;
      case '5':
        await runMigrations();
        break;
      case '6':
        logger.title('Running Full Iteration');
        await runLint();
        const buildSuccess = await buildProject();
        if (buildSuccess) {
          await runMigrations();
          logger.success('All tasks completed successfully');
        }
        break;
      case '7':
        logger.info('Exiting...');
        stopAllProcesses();
        rl.close();
        return;
      default:
        logger.warning('Invalid option, please try again');
    }

    // Add a small delay before showing the menu again
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }
};

/**
 * Process command line arguments and run the appropriate action
 */
const processArguments = async () => {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    // No arguments, show interactive menu
    await showIterationMenu();
    return;
  }

  switch (args[0]) {
    case 'start':
      await startDevServer();
      break;
    case 'status':
      await checkStatus();
      break;
    case 'lint':
      await runLint();
      break;
    case 'build':
      await buildProject();
      break;
    case 'migrate':
      await runMigrations();
      break;
    case 'iterate':
      await runLint();
      const buildSuccess = await buildProject();
      if (buildSuccess) {
        await runMigrations();
        await startDevServer();
      }
      break;
    default:
      logger.error(`Unknown command: ${args[0]}`);
      logger.info(
        'Available commands: start, status, lint, build, migrate, iterate',
      );
      process.exit(1);
  }
};

// Handle exit signals to clean up processes
process.on('SIGINT', () => {
  logger.info('Received interrupt signal, shutting down...');
  stopAllProcesses();
  process.exit(0);
});

process.on('SIGTERM', () => {
  logger.info('Received termination signal, shutting down...');
  stopAllProcesses();
  process.exit(0);
});

// Main entry point
(async () => {
  try {
    await processArguments();
  } catch (error) {
    logger.error(`An unexpected error occurred: ${error.message}`);
    logger.error(error.stack);
    process.exit(1);
  }
})();
