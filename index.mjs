import { Octokit } from "@octokit/rest";
import { config } from "dotenv";
import fs from "fs-extra";
import { Parser } from "json2csv";

config();
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const AI_TOOLS = [
  "copilot",
  "chatgpt",
  "cursor",
  "gemini",
  "grok",
  "codewhisperer",
  "amazonQ",
  "codeium",
  "deepseek",
];

const SEARCH_TERMS = [
  "created by",
  "generated by",
  "use",
  "using",
  "with",
  "powered by",
  "assisted by",
  "written with",
  "suggested by",
  "completed by",
  "AI-generated",
  "generated code",
  "generated with",
  "written using",
  "written by",
];

const LANGUAGES = ["JavaScript", "TypeScript"];

const PER_PAGE = 30; // max allowed
const CACHE_FILE = "./progress_cache.json";
const CSV_FILE = "./ai_code_dataset.csv";

// Load or init state
let state = await (async () => {
  if (await fs.pathExists(CACHE_FILE)) {
    let raw = await fs.readJson(CACHE_FILE);
    raw.seen = new Set(raw.seen);
    return raw;
  }
  return { i: 0, j: 0, k: 0, page: 1, nextId: 1, results: [], seen: new Set() };
})();

async function saveState() {
  await fs.writeJson(
    CACHE_FILE,
    {
      i: state.i,
      j: state.j,
      k: state.k,
      page: state.page,
      nextId: state.nextId,
      results: state.results,
      seen: [...state.seen],
    },
    { spaces: 2 }
  );
}

async function saveCsv() {
  if (!state.results.length) return;
  const csv = new Parser().parse(state.results);
  await fs.writeFile(CSV_FILE, csv);
}

// Rate‚Äêlimit guard for core 5k‚Äêper‚Äêhour bucket
async function guardCore() {
  const {
    data: { rate },
  } = await octokit.rateLimit.get();
  if (rate.remaining < 50) {
    const ms = rate.reset * 1000 - Date.now();
    console.log(`üõë CORE limit low; sleeping ${Math.ceil(ms / 1000)}s`);
    await new Promise((r) => setTimeout(r, ms));
  }
}

// Simple throttle to stay under ~30 searches/min
async function throttleSearch() {
  await new Promise((r) => setTimeout(r, 4000)); // 2s pause =>
  // ~30 reqs/min
}

async function crawl() {
  try {
    for (; state.i < AI_TOOLS.length; state.i++, state.j = 0, state.k = 0) {
      const tool = AI_TOOLS[state.i];
      for (; state.j < SEARCH_TERMS.length; state.j++, state.k = 0) {
        const phrase = SEARCH_TERMS[state.j];
        for (; state.k < LANGUAGES.length; state.k++) {
          const lang = LANGUAGES[state.k];
          const query = `"${phrase} ${tool}" language:${lang}`;
          console.log(`üîç [${state.i},${state.j},${state.k}] ${query}`);

          // reset pagination
          state.page = 1;

          while (state.page <= 30) {
            await guardCore();
            await throttleSearch();

            let response;
            try {
              response = await octokit.search.code({
                q: query,
                per_page: PER_PAGE,
                page: state.page,
                sort: "indexed",
                order: "desc",
              });
            } catch (err) {
              // Secondary‚Äêlimit (abuse) wrapper
              if (
                err.status === 403 &&
                /secondary rate limit/i.test(err.message)
              ) {
                console.warn("üö¶ secondary limit ‚Äì sleeping 60s");
                await new Promise((r) => setTimeout(r, 60_000));
                continue; // retry same page
              }
              throw err;
            }

            const items = response.data.items;
            if (!items.length) break; // no more pages

            for (const it of items) {
              // only JS/TS
              if (!it.path.match(/\.(js|ts)$/)) continue;
              if (state.seen.has(it.html_url)) continue;

              try {
                const owner = it.repository.owner.login;
                const repo = it.repository.name;

                const [repoInfo, fileInfo] = await Promise.all([
                  octokit.repos.get({ owner, repo }),
                  octokit.repos.getContent({ owner, repo, path: it.path }),
                ]);

                const raw = Buffer.from(
                  fileInfo.data.content,
                  "base64"
                ).toString("utf8");
                const loc = raw.split("\n").length;
                const raw_url = `https://raw.githubusercontent.com/${it.repository.full_name}/HEAD/${it.path}`;

                state.results.push({
                  id: state.nextId++,
                  tool,
                  phrase,
                  lang,
                  repo: it.repository.full_name,
                  file: it.path,
                  file_url: it.html_url,
                  raw_url,
                  stars: repoInfo.data.stargazers_count,
                  forks: repoInfo.data.forks_count,
                  desc: repoInfo.data.description || "",
                  loc,
                  snippet: raw.replace(/\r?\n|\r/g, " ").slice(0, 5000),
                });
                state.seen.add(it.html_url);
              } catch (e) {
                console.warn(`‚ö†Ô∏è skipping ${it.html_url}: ${e.message}`);
              }
            }

            state.page++;
            await saveState();
            await saveCsv();
          } // page‚Äêwhile
        } // lang
        state.k = 0;
      } // phrase
      state.j = 0;
    } // tool

    // done
    await saveCsv();
    await fs.remove(CACHE_FILE);
    console.log("‚úÖ done, wrote", CSV);
  } catch (e) {
    console.error("‚ùå CRASH:", e);
    await saveState();
    await saveCsv();
  }
}

crawl();
